# Messaging protocol

**Note: This article is a work in progress.**

The drachtio server is controlled by drachtio-srf applications using a utf8-based messaging protocol over a tcp connection.  

Because some developers have expressed an interest in integrating other language frameworks (e.g. go) to the drachtio server, this section aims to give some details of that protocol.  As highlighted above, it is a work in progress.

As per the documention found elsewhere on this site, drachtio supports both inbound and [outbound](/docs/developer-guide#advanced-topics) connections.  To begin with, we will focus here on describing the message flows for inbound connections.

## Basic message format
Messages are utf8-encoded.  (This was not always the case - originally ascii was used, but this broke down with applications that needed to receive and send information like emojis!).  

Each message starts with a decimal number indicating the number of bytes in the message (again, this is utf-8 so number of characters does not necessarily mean number of bytes!), followed by a hash sign ('#').  The number of bytes specified does **not** include these leading decimal digits or the hash sign -- they indicate the length of the payload that follows.

The messsge payload that follows this consists of 1 or more lines of data, where each line is terminated by a CRLF.

Typically, the first line of payload data consists of a list of tokens, where each token is delimited by a '|' character.  When SIP messages are exchanged between application and server, these are usually carried starting on the second line of data, and are simply represented exactly as they appear "on the wire" between SIP endpoints.

### How to see messages being exchanged
For those interested, note that is is possible to generate a trace file of all messaging between the client and the server by setting a property on the `Srf` instance, e.g.:
```js
const Srf = require('drachtio-srf');
const srf = new Srf();

// this will cause all messages between client and server to be logged to a file
srf.set('api logger', '/tmp/messages.log');
```

## Connection and authentication
An inbound connection scenario starts when an application, acting as a TCP client, connects to a drachtio server on its configured admin port.

After the connection is established, the application must authenticate itself via the shared secret that is configured in the `drachtio.conf.xml` configuration file on the server.  If the client is authenticated, the server returns information including the sip hostports (e.g. list of address:port) that the server is listening on.

Let's look at an example of a successful authentication.  Not all of this will immediately be clear, but we will review the individual message elements below.
```
===>56#12ad33a1-9f33-40b7-b327-b2e32bfcd9e8|authenticate|cymru|

<===465#2f8216a3-babf-4cdb-93c6-254fe8dba42d|response|12ad33a1-9f33-40b7-b327-b2e32bfcd9e8|OK|tcp/[::1]:5060,udp/[::1]:5060,tcp/127.0.0.1:5060,tcp/10.0.0.121:5060,udp/127.0.0.1:5060,tcp/[2601:182:cd00:5786::4a1e]:5060,udp/[2601:182:cd00:5786::4a1e]:5060,tcp/[2601:182:cd00:5786:a534:e8d4:3dcb:3553]:5060,udp/[2601:182:cd00:5786:a534:e8d4:3dcb:3553]:5060,udp/10.0.0.121:5060,tcp/[2601:182:cd00:5786:1866:49f9:e83b:9574]:5060,udp/[2601:182:cd00:5786:1866:49f9:e83b:9574]:5060
```
> Note: the direction `===>` indicates a message sent from an application to the server; the reverse indicates a message sent from the server to the application

We see that after connecting, the application sends an authenticate request to the server.  The authenticate request consists of a single line containing three (3) tokens:
* a unique message identifier, generated by the client application (needs to be unique only for this client),
* the message type ('authenticate')
* the shared secret ('cymru')

The server validates the shared secret, and returns a message consisting of one line, containing the following tokens:
* a unique message identifier for the response
* the message type ('response')
* the message id of the associated request
* the response status ('OK')
* a comma-delimited string containing the sip hostports the server is listening on

At this point, the client has connected and authenticated successfully, but it has not yet registered the SIP request types that it would like to receive.  That happens next.

## Registering to handle SIP requests
In order to notify the server that the application wishes to handle specific SIP request types, it is necessary to issue a 'route' command.  This is typically the next thing a client application does after authenticating.  It is only necessary to register for request types once, during startup (i.e., after actually handling an incoming request it is not necessary to re-register in order to get further requests).
> Registering for request types is taken care of automatically in a drachtio-srf app when a `srf.invite()` statement is processed, for example.

```
# registering to receive INVITEs
===>49#5e60fef0-409f-4980-a859-94810d002ebb|route|invite
<===85#e7470b05-95be-448e-94cd-3935292c4956|response|5e60fef0-409f-4980-a859-94810d002ebb|OK
```
> Note: to register for multiple request types (e.g. INVITE and REGISTER) the application must issue spearate 'route' commands.

The 'route' command consists of a single line containing the following tokens:
* a message id
* the command ('route')
* the SIP request type

The response, as before, contains its own message id as well as the message id of the request, and the status ('OK').

At this point, the server will start sending SIP requests of the requested type to the application for handling.  Let's look at what happens next.

## Handling an incoming SIP request
Let's start with something simple: receiving a SIP INVITE and sending a non-success response.

The basic message flow is this:
* The server receives a SIP INVITE, selects the client application to send it to for handling, and sends a 'sip' message type to the client app containing the full SIP request message, as well as additional detail (e.g. the source_address and port etc)
* The client application receives the message and sends a sip response message, containing at least the SIP status as well as any headers that it wants set to any non-default values.
* The server sends out the SIP response on the network and then sends another message back to the client containing the exact message that was sent out over the wire.

With that as background, let's examine the message trace.  To make it interesting, we will have the client application add a custom SIP header to the response.  

We will also see now our first example of messages containining multiple lines, since we are now carrying SIP messages back and forth between client and server:
```
<===866#83936ddb-523a-4cd0-886e-92b484905d85|sip|network|732|udp|127.0.0.1|50500|16:06:41.114233|8f62909b-0f25-4bb8-b0fc-2c0ec88a4afe|\r\n
INVITE sip:15083084809@127.0.0.1 SIP/2.0\r\n
Via: SIP/2.0/UDP 127.0.0.1:50500;branch=z9hG4bK-524287-1---f8002e51f06e3b38;rport=50500\r\n
Max-Forwards: 70\r\n
Contact: <sip:dhorton@127.0.0.1:50500>\r\n
To: <sip:15083084809@127.0.0.1>\r\n
From: <sip:dhorton@127.0.0.1>;tag=ce2ff21e\r\n
Call-ID: 92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E\r\n
CSeq: 1 INVITE\r\n
Allow: SUBSCRIBE, NOTIFY, INVITE, ACK, CANCEL, BYE, REFER, INFO, OPTIONS\r\n
Content-Type: application/sdp\r\n
Supported: replaces\r\nUser-Agent: Bria 5 release 5.3.1 stamp 92383\r\n
Content-Length: 202\r\n
\r\n
v=0\r\n
o=- 1531670801092727 1 IN IP4 127.0.0.1\r\n
s=Bria 5 release 5.3.1 stamp 92383\r\n
c=IN IP4 127.0.0.1\r\n
t=0 0\r\n
m=audio 52282 RTP/AVP 0 101\r\n
a=rtpmap:101 telephone-event/8000\r\n
a=fmtp:101 0-15\r\n
a=sendrecv\r\n

===>332#829ba63e-5010-4719-b72f-cb3cf6f4aab2|sip|8f62909b-0f25-4bb8-b0fc-2c0ec88a4afe|\r\n
SIP/2.0 486 Busy Here\r\n
Call-ID: 92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E\r\n
cseq: 1 INVITE\r\n
from: <sip:dhorton@127.0.0.1>;tag=ce2ff21e\r\n
to: <sip:15083084809@127.0.0.1>\r\n
Content-Length: 0\r\nuser-agent: drachtio\r\n
X-custom: my custom header value\r\n

<===600#d04f4d88-108c-4d93-a3f9-e9967b63ff55|response|829ba63e-5010-4719-b72f-cb3cf6f4aab2|OK|application|359|udp|127.0.0.1|50500|16:06:41.127954|8f62909b-0f25-4bb8-b0fc-2c0ec88a4afe|92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E;uas||Msg sent:|\r\n
SIP/2.0 486 Busy Here\r\n
Via: SIP/2.0/UDP 127.0.0.1:50500;branch=z9hG4bK-524287-1---f8002e51f06e3b38;rport=50500\r\n
From: <sip:dhorton@127.0.0.1>;tag=ce2ff21e\r\n
To: <sip:15083084809@127.0.0.1>;tag=cjSXXKtQejgrg\r\n
Call-ID: 92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E\r\n
CSeq: 1 INVITE\r\n
User-Agent: drachtio\r\n
Content-Length: 0\r\n
X-custom: my custom header value\r\n
```

Let's examine the first message -- the one sent by the server to the application, giving it an incoming INVITE message to handle.

As usual, after the length specifier we see the message payload begins with the message identifier.

After that, we have the message type, which in this case is 'sip'.  We've now almost all of the message types (there aren't that many!), so let's pause here and briefly give the full list:
* 'authenticate' 
* 'route' 
* 'response'
* 'sip'
* 'cdr:attempt'
* 'cdr:start'
* 'cdr:stop'

In the case of a new incoming 'sip' request sent by the drachtio server we have the following tokens on the first line of the message payload:
* message id
* message type ('sip')
* message source ('network' or 'application', depending on whether the app received or sent the msg)
* length of the SIP message, as received over the wire
* transport protocol
* source address
* source port
* time message was received (as reported by the sofia sip stack)
* unique id assigned by the server for this SIP transaction
* unique id assigned by the server for this SIP Dialog (not always present, since a Dialog may not exist for this request)

Following the first line of payload the incoming SIP message in its entirety is provided.

At this point it is the responsibility of the application to return the desired SIP response that it wishes the server to send out.  We see in the example above that the application also uses the 'sip' message type to accomplish this.  The first line of payload contains the following tokens:
* message id
* message type ('sip')
* the transaction id that the sip response pertains to

Following that we have the message itself.  Note that it is **not** necessary to provide the full SIP response message -- based on the transaction id, most of the headers will be supplied by the drachtio server.  The application must minimally provide the SIP status line (in our example, drachtio-srf is populating several other headers such as To, From, etc but this should not be necessary).  Additionally, if a body is desired in the response (which is not in our example), then that would be provided by the application as well (in the normal way of separating the body from any headers with two (2) CRLFs).

The drachtio server sends out the indicated response and then notifies the application of the exact SIP response that was sent out over the wire.  This allows the application to learn about information, such as the tag on the SIP To header, that the server itself would have applied.

This final message has the following payload:
* message id
* message type ('response')
* related message id (in this case, the 'sip' response message sent by the application)
* message status ('OK')
* message source ('application', indicating this was a message sent by the application)
* length of the SIP message
* transport protocol used
* remote address sent to
* remote port sent to
* time message was sent (as reported by the sofia sip stack)
* related transaction id
* unique dialog id created by the server to represent this SIP Dialog

> Note: the additional tokens at the end of the first line (a blank token, and the string 'Msg sent') can be ignored; they are placeholders that are used in scenarios where the application has sent a SIP request, not a response.


