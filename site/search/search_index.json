{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"developer-guide/advanced-topics/","text":"Advanced Topics Outbound connections The examples so far have illustrated inbound connections ; that is, a drachtio application establishing a tcp connection to a drachtio server. These are created by calling Srf#connect : const Srf = require('drachtio-srf'); const srf = new Srf(); // example of creating inbound connections srf.connect({ host: '192.168.1.100', port: 9022, secret: 'cymru' }); srf.on('connect', (hp) = console.log(`connected to drachtio listening on ${hp}`)); srf.on('error', (err) = console.log(`error connecting: ${err}`)); srf.invite((req, res) = {..}); An inbound connection is intended to be a long lasting connection: the application connects when the application starts, and that connection is then used to transmit all SIP events and commands as long as the application is running. Note: If the connection between the drachtio client and the server is interrupted, it will be automatically reestablished as long as the application has installed a listener for the 'error' event on the Srf instance. Inbound connections are generally most useful in scenarios when a drachtio server is single-purposed, meaning all SIP requests are handled by a single application. For example, if a drachtio server is specifically purposed to be a SIP proxy, and all incoming calls are treated by the same application logic, then an inbound connection between the drachtio application and server would probably be preferred. However, it is also possible for the connections between the drachtio application and the server to be reversed: that is, the drachtio server establishes the connection to a drachtio server on a per-call (more specifically, a per SIP request) basis. This is called an outbound connection , and it requires two things: 1. The drachtio server configuration file must include a request-handler xml section that maps a specific SIP method type to an HTTP web callback, and 2. The drachtio application must call the Srf#listen method, which causes it to listen for connections from a drachtio server rather than initiate them. The sequence of events when outbound connections have been enabled are as follows: 1. The drachtio application starts, and begins listening on a specific IP address and port for connections from drachtio servers. 2. An incoming INVITE request (for example) is received by a drachtio server. 3. Because the drachtio server has been configured with a web callback for INVITE request types, an HTTP GET request is made to the web callback. Information about the incoming call is passed to the web callback via url parameters in the request. 4. The web callback -- which is a user-supplied web app -- returns a JSON body indicating the ip address or dns name and tcp port where the drachtio application is listening. 5. The drachtio server retrieves the ip address and port from the response to the web callback and establishes a tcp connection to the drachtio application listening on that address:port. 6. The INVITE information is sent to the drachtio application over this new connection, and the standard drachtio middleware is invoked; e.g. srf.invite((req, res)) . const Srf = require('drachtio-srf'); const srf = new Srf(); // example of listening for outbound connections srf.listen({ port: 3001, secret: 'cymru' }); srf.invite((req, res) = {..}); From the standpoint of the drachtio application you would write, the code is almost exactly the same other than the call to Srf#listen instead of Srf#connect and one other matter related to eventually releasing the connection, which we will describe shortly. Mixing inbound and outbound connections Is it possible to mix inbound and outbound connections? Sort of. Here are the limitations: A drachtio server can have both inbound and outbound connections, but a given SIP method type (e.g. INVITE) will exclusively use one or the other. Specifically, if there is a request-handler element with a sip-method property set to either the method name or * , then outbound connections will be used for all incoming SIP requests of that method type; otherwise inbound connections will be used. A single Srf instance must exclusively use only inbound or outbound connections; that is to say that it must call either Srf#connect or Srf#listen but not both. A single application that wants to use both must create two (or more) Srf instances, or alternatively the functionality can be split into multiple applications. Terminating outbound connections We mentioned above that inbound connections are long-lasting. Outbound connections are not. An outbound connection is established when a specific SIP request arrives, and it is intended to last only until the application has determined that all logic related to that request has been performed. From a practical standpoint, since each new arriving request spawns a new tcp connection, it is important that connections are destroyed when the application logic is complete, so that we don't exhaust file descriptor or other resources on the server. Because the determination of \"when all application logic has complete\" is, by definition, something that only the application can know, we require the application to destroy the connection via an explicit call to Srf#endSession when it is no longer needed. Typically, an application will call this method when all SIP dialogs or transactions associated with or emanating from the initial SIP request have been destroyed. In a simple example of a UAS app connecting an incoming call, for instance, when the BYE that terminates the call is sent or received it would be appropriate to call Srf#endSession . This method call is a 'no-op' (does nothing) when called on an inbound connection, so it is safe to call in code that may be dealing with an outbound or inbound connection. When to use outbound connections There are two primary scenarios in which to use outbound connections: When a single drachtio server is going to handle calls controlled by multiple different types of applications. In this scenario, it can be useful to have a web callback examine the incoming calls and distribute them appropriately to the different drachtio applications based on per-call information. For example, if we wanted to stand up a drachtio server that multiple customers could utilize (i.e. multi-tenant situation) then outbound connections would allow us to have many different customer applications controlling calls on that server, each applying their own logic. When drachtio applications are going to run in a containerized cluster environment such as Kubernetes, outbound connections can be useful. In this environment, it can be useful to create a Kubernetes Service for the drachtio cluster, and then use outbound connections to route incoming calls to the public address of the Kubernetes Service which is backed by a cluster of drachtio applications running in Kubernetes pods. In general, outbound connections can make it easier to independently scale drachtio servers and groups of drachtio applications, since you do not need to explicitly \"tie\" drachtio applications to specific servers. For more information on configuring drachtio server for outbound connections refer to the drachtio server configuration documentation . Using TLS to encrypt messages between application and server As of drachtio server release 0.8.0-rc1 and drachtio-srf release 4.4.0, it is possible to encrypt the messages between the drachtio server and your application. This may be useful in situations where applications are running remotely and you prefer to encrypt the control messages as they pass through intervening networks. Both inbound and outbound connections can use TLS encryption, though the configuration steps are different as described below. Securing inbound connections using TLS To use TLS on inbound connections, simply configure the drachtio server to listen on a specific port for TLS traffic, in addition to (or in place of) TCP traffic. For example: admin port= 9022 tls-port= 9023 secret= cymru 127.0.0.1 /admin would cause the server to listen for tcp connections on port 9022 and tls connections on port 9023. You can also specify the port on the command line: drachtio --tls-port 9023 In addition to specifying a port to listen for tls traffic, you must specify minimally a server key, a certificate, and a dhparam file. These are specified in the 'tls' section of the config file: tls key-file /etc/letsencrypt/live/example.org/privkey.pem /key-file cert-file /etc/letsencrypt/live/example.org/cert.pem /cert-file chain-file /etc/letsencrypt/live/example.org/chain.pem /chain-file dh-param /var/local/private/dh4096.pem /dh-param /tls Of course, these can also be specified via the command line as well: drachtio --dh-param /var/local/private/dh4096.pem \\ --cert-file /etc/letsencrypt/live/example.org/cert.pem \\ --chain-file /etc/letsencrypt/live/example.org/chain.pem \\ --key-file /etc/letsencrypt/live/example.org/privkey.pem drachtio-srf app configuration On the client side, when connecting to a TLS port the Srf#connect function call must include a 'tls' object parameter in the options passed: this.srf.connect({ host: '127.0.0.1', port: 9023, tls: { rejectUnauthorized: false } }); Any of the node.js tls options that can be passed to tls.createSecureContext can be passed. Even if you do not need to include any options, you must still include an empty object as the opts.tls param in order to signal the underlying library that you wish to establish a TLS connection. Using self-signed certificate on the server If you are using a self-signed certificate on the server, then you must load that same certificate on the client, as below: this.srf.connect({ host: '127.0.0.1', port: 9023, tls: { ca: fs.readFileSync('server.crt'), rejectUnauthorized: false } }); Securing outbound connections using TLS To use TLS to secure outbound connections, there is no specific configuration needed on the server. You just need your http request handler to return a uri with a transport=tls parameter, e.g.: { uri : 10.32.100.2:808;transport=tls } drachtio-srf configuration On the application side, to listen for TLS connections you will need to modify the Srf#listen function to pass tls options. Minimally, you must specify a private key and certificate. srf.listen({ port: 8080, tls: { key: fs.readFileSync('server.key'), cert: fs.readFileSync('server.crt'), rejectUnauthorized: false } });","title":"advanced topics"},{"location":"developer-guide/advanced-topics/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"developer-guide/advanced-topics/#outbound-connections","text":"The examples so far have illustrated inbound connections ; that is, a drachtio application establishing a tcp connection to a drachtio server. These are created by calling Srf#connect : const Srf = require('drachtio-srf'); const srf = new Srf(); // example of creating inbound connections srf.connect({ host: '192.168.1.100', port: 9022, secret: 'cymru' }); srf.on('connect', (hp) = console.log(`connected to drachtio listening on ${hp}`)); srf.on('error', (err) = console.log(`error connecting: ${err}`)); srf.invite((req, res) = {..}); An inbound connection is intended to be a long lasting connection: the application connects when the application starts, and that connection is then used to transmit all SIP events and commands as long as the application is running. Note: If the connection between the drachtio client and the server is interrupted, it will be automatically reestablished as long as the application has installed a listener for the 'error' event on the Srf instance. Inbound connections are generally most useful in scenarios when a drachtio server is single-purposed, meaning all SIP requests are handled by a single application. For example, if a drachtio server is specifically purposed to be a SIP proxy, and all incoming calls are treated by the same application logic, then an inbound connection between the drachtio application and server would probably be preferred. However, it is also possible for the connections between the drachtio application and the server to be reversed: that is, the drachtio server establishes the connection to a drachtio server on a per-call (more specifically, a per SIP request) basis. This is called an outbound connection , and it requires two things: 1. The drachtio server configuration file must include a request-handler xml section that maps a specific SIP method type to an HTTP web callback, and 2. The drachtio application must call the Srf#listen method, which causes it to listen for connections from a drachtio server rather than initiate them. The sequence of events when outbound connections have been enabled are as follows: 1. The drachtio application starts, and begins listening on a specific IP address and port for connections from drachtio servers. 2. An incoming INVITE request (for example) is received by a drachtio server. 3. Because the drachtio server has been configured with a web callback for INVITE request types, an HTTP GET request is made to the web callback. Information about the incoming call is passed to the web callback via url parameters in the request. 4. The web callback -- which is a user-supplied web app -- returns a JSON body indicating the ip address or dns name and tcp port where the drachtio application is listening. 5. The drachtio server retrieves the ip address and port from the response to the web callback and establishes a tcp connection to the drachtio application listening on that address:port. 6. The INVITE information is sent to the drachtio application over this new connection, and the standard drachtio middleware is invoked; e.g. srf.invite((req, res)) . const Srf = require('drachtio-srf'); const srf = new Srf(); // example of listening for outbound connections srf.listen({ port: 3001, secret: 'cymru' }); srf.invite((req, res) = {..}); From the standpoint of the drachtio application you would write, the code is almost exactly the same other than the call to Srf#listen instead of Srf#connect and one other matter related to eventually releasing the connection, which we will describe shortly.","title":"Outbound connections"},{"location":"developer-guide/advanced-topics/#mixing-inbound-and-outbound-connections","text":"Is it possible to mix inbound and outbound connections? Sort of. Here are the limitations: A drachtio server can have both inbound and outbound connections, but a given SIP method type (e.g. INVITE) will exclusively use one or the other. Specifically, if there is a request-handler element with a sip-method property set to either the method name or * , then outbound connections will be used for all incoming SIP requests of that method type; otherwise inbound connections will be used. A single Srf instance must exclusively use only inbound or outbound connections; that is to say that it must call either Srf#connect or Srf#listen but not both. A single application that wants to use both must create two (or more) Srf instances, or alternatively the functionality can be split into multiple applications.","title":"Mixing inbound and outbound connections"},{"location":"developer-guide/advanced-topics/#terminating-outbound-connections","text":"We mentioned above that inbound connections are long-lasting. Outbound connections are not. An outbound connection is established when a specific SIP request arrives, and it is intended to last only until the application has determined that all logic related to that request has been performed. From a practical standpoint, since each new arriving request spawns a new tcp connection, it is important that connections are destroyed when the application logic is complete, so that we don't exhaust file descriptor or other resources on the server. Because the determination of \"when all application logic has complete\" is, by definition, something that only the application can know, we require the application to destroy the connection via an explicit call to Srf#endSession when it is no longer needed. Typically, an application will call this method when all SIP dialogs or transactions associated with or emanating from the initial SIP request have been destroyed. In a simple example of a UAS app connecting an incoming call, for instance, when the BYE that terminates the call is sent or received it would be appropriate to call Srf#endSession . This method call is a 'no-op' (does nothing) when called on an inbound connection, so it is safe to call in code that may be dealing with an outbound or inbound connection.","title":"Terminating outbound connections"},{"location":"developer-guide/advanced-topics/#when-to-use-outbound-connections","text":"There are two primary scenarios in which to use outbound connections: When a single drachtio server is going to handle calls controlled by multiple different types of applications. In this scenario, it can be useful to have a web callback examine the incoming calls and distribute them appropriately to the different drachtio applications based on per-call information. For example, if we wanted to stand up a drachtio server that multiple customers could utilize (i.e. multi-tenant situation) then outbound connections would allow us to have many different customer applications controlling calls on that server, each applying their own logic. When drachtio applications are going to run in a containerized cluster environment such as Kubernetes, outbound connections can be useful. In this environment, it can be useful to create a Kubernetes Service for the drachtio cluster, and then use outbound connections to route incoming calls to the public address of the Kubernetes Service which is backed by a cluster of drachtio applications running in Kubernetes pods. In general, outbound connections can make it easier to independently scale drachtio servers and groups of drachtio applications, since you do not need to explicitly \"tie\" drachtio applications to specific servers. For more information on configuring drachtio server for outbound connections refer to the drachtio server configuration documentation .","title":"When to use outbound connections"},{"location":"developer-guide/advanced-topics/#using-tls-to-encrypt-messages-between-application-and-server","text":"As of drachtio server release 0.8.0-rc1 and drachtio-srf release 4.4.0, it is possible to encrypt the messages between the drachtio server and your application. This may be useful in situations where applications are running remotely and you prefer to encrypt the control messages as they pass through intervening networks. Both inbound and outbound connections can use TLS encryption, though the configuration steps are different as described below.","title":"Using TLS to encrypt messages between application and server"},{"location":"developer-guide/advanced-topics/#securing-inbound-connections-using-tls","text":"To use TLS on inbound connections, simply configure the drachtio server to listen on a specific port for TLS traffic, in addition to (or in place of) TCP traffic. For example: admin port= 9022 tls-port= 9023 secret= cymru 127.0.0.1 /admin would cause the server to listen for tcp connections on port 9022 and tls connections on port 9023. You can also specify the port on the command line: drachtio --tls-port 9023 In addition to specifying a port to listen for tls traffic, you must specify minimally a server key, a certificate, and a dhparam file. These are specified in the 'tls' section of the config file: tls key-file /etc/letsencrypt/live/example.org/privkey.pem /key-file cert-file /etc/letsencrypt/live/example.org/cert.pem /cert-file chain-file /etc/letsencrypt/live/example.org/chain.pem /chain-file dh-param /var/local/private/dh4096.pem /dh-param /tls Of course, these can also be specified via the command line as well: drachtio --dh-param /var/local/private/dh4096.pem \\ --cert-file /etc/letsencrypt/live/example.org/cert.pem \\ --chain-file /etc/letsencrypt/live/example.org/chain.pem \\ --key-file /etc/letsencrypt/live/example.org/privkey.pem","title":"Securing inbound connections using TLS"},{"location":"developer-guide/advanced-topics/#drachtio-srf-app-configuration","text":"On the client side, when connecting to a TLS port the Srf#connect function call must include a 'tls' object parameter in the options passed: this.srf.connect({ host: '127.0.0.1', port: 9023, tls: { rejectUnauthorized: false } }); Any of the node.js tls options that can be passed to tls.createSecureContext can be passed. Even if you do not need to include any options, you must still include an empty object as the opts.tls param in order to signal the underlying library that you wish to establish a TLS connection.","title":"drachtio-srf app configuration"},{"location":"developer-guide/advanced-topics/#using-self-signed-certificate-on-the-server","text":"If you are using a self-signed certificate on the server, then you must load that same certificate on the client, as below: this.srf.connect({ host: '127.0.0.1', port: 9023, tls: { ca: fs.readFileSync('server.crt'), rejectUnauthorized: false } });","title":"Using self-signed certificate on the server"},{"location":"developer-guide/advanced-topics/#securing-outbound-connections-using-tls","text":"To use TLS to secure outbound connections, there is no specific configuration needed on the server. You just need your http request handler to return a uri with a transport=tls parameter, e.g.: { uri : 10.32.100.2:808;transport=tls }","title":"Securing outbound connections using TLS"},{"location":"developer-guide/advanced-topics/#drachtio-srf-configuration","text":"On the application side, to listen for TLS connections you will need to modify the Srf#listen function to pass tls options. Minimally, you must specify a private key and certificate. srf.listen({ port: 8080, tls: { key: fs.readFileSync('server.key'), cert: fs.readFileSync('server.crt'), rejectUnauthorized: false } });","title":"drachtio-srf configuration"},{"location":"developer-guide/call-detail-records/","text":"Call Detail Records Generating call detail records (CDRs) is a standard requirement for SIP servers. The drachio-server process generates the following types of CDRs: * a call attempt record is generated when a call attempt (i.e., INVITE) is either received or generated by the server * a call start record is generated when a call is connected (i.e., 200 OK either sent or received), and * a call stop record is generated when a call ends or a non-successful INVITE transaction completes. It follows from the above that a successful completed call will generate three CDRs (call attempt, call start, call stop), while a failed INVITE will only generate two CDRs (call attempt, call end). An application registers to receive CDRs by registering for events as illustrated below. const Srf = require('drachtio-srf'); const srf = new Srf(); const config = require('config'); srf.connect(config.get('drachtio')) .on('error', (err) = console.error(`Error connecting: ${err}`)); // register to receive CDRs srf.on('cdr:attempt', (source, time, msg) = { console.log(`got attempt record from ${source} at ${time}: msg.get('Call-Id')`) ; // got attempt record from network at 20:05:58.130582: 671261870@42.55.72.99 }); srf.on('cdr:start', (source, time, role, msg) = { console.log(`got start record from ${source} at ${time} with role ${role}: msg.get('Call-Id')`) ; // got start record from network at 20:05:59.781505 with role uas: 671261870@42.55.72.99 }); srf.on('cdr:stop', (source, time, reason, msg) = { console.log(`got stop record from ${source} at ${time} with reason ${reason}: msg.get('Call-Id')`) ; // got stop record from network at 20:06:22.695850 with reason normal-release: 671261870@42.55.72.99 }); Note that it is completely possible to have one specialized application connecting and receiving CDRs, while other applications are performing the call control logic. This ability to separate CDR generation from application logic is often desirable in larger, more complex systems. The cdr events provide the following information elements: * source : either 'network' or 'application', depending on whether the INVITE was received by or sent from the drachtio server, respectively. * time : the UTC time that the request was sent or received * role : the role that the drachtio server is playing with regards to this INVITE request: + 'uas': the server is receiving the INVITE as a UAS + 'uac': the server is generating the INVITE as a UAC + 'proxy-uac': the server is forwarding an INVITE as a proxy + 'proxy-uas': the server is receiving an INVITE as a proxy * reason : the termination reason for the call + 'call-rejected': the INVITE was rejected with a non-success final status + 'call-canceled': the INVITE was canceled by the sender before answer + 'normal-release': the call was connected and later released normally by one side or the other + 'session-expired': the call was connected and later torn down by the drachtio server because the session expired * msg : + for 'cdr:attempt', the INVITE request + for 'cdr:start', the 200 OK + for 'cdr:stop', the final non-success response (if reason is 'call-rejected'), otherwise the BYE request taht was sent or received to terminate the Dialog. Further information about the call, such as calling and called party numbers, can be retrieved from the msg parameter using the properties and methods of the SIP Message object . Note: an application that wishes to receive CDR events must establish an inbound connection to the drachtio server, since CDR events are not currently sent over outbound connections.","title":"call detail records"},{"location":"developer-guide/call-detail-records/#call-detail-records","text":"Generating call detail records (CDRs) is a standard requirement for SIP servers. The drachio-server process generates the following types of CDRs: * a call attempt record is generated when a call attempt (i.e., INVITE) is either received or generated by the server * a call start record is generated when a call is connected (i.e., 200 OK either sent or received), and * a call stop record is generated when a call ends or a non-successful INVITE transaction completes. It follows from the above that a successful completed call will generate three CDRs (call attempt, call start, call stop), while a failed INVITE will only generate two CDRs (call attempt, call end). An application registers to receive CDRs by registering for events as illustrated below. const Srf = require('drachtio-srf'); const srf = new Srf(); const config = require('config'); srf.connect(config.get('drachtio')) .on('error', (err) = console.error(`Error connecting: ${err}`)); // register to receive CDRs srf.on('cdr:attempt', (source, time, msg) = { console.log(`got attempt record from ${source} at ${time}: msg.get('Call-Id')`) ; // got attempt record from network at 20:05:58.130582: 671261870@42.55.72.99 }); srf.on('cdr:start', (source, time, role, msg) = { console.log(`got start record from ${source} at ${time} with role ${role}: msg.get('Call-Id')`) ; // got start record from network at 20:05:59.781505 with role uas: 671261870@42.55.72.99 }); srf.on('cdr:stop', (source, time, reason, msg) = { console.log(`got stop record from ${source} at ${time} with reason ${reason}: msg.get('Call-Id')`) ; // got stop record from network at 20:06:22.695850 with reason normal-release: 671261870@42.55.72.99 }); Note that it is completely possible to have one specialized application connecting and receiving CDRs, while other applications are performing the call control logic. This ability to separate CDR generation from application logic is often desirable in larger, more complex systems. The cdr events provide the following information elements: * source : either 'network' or 'application', depending on whether the INVITE was received by or sent from the drachtio server, respectively. * time : the UTC time that the request was sent or received * role : the role that the drachtio server is playing with regards to this INVITE request: + 'uas': the server is receiving the INVITE as a UAS + 'uac': the server is generating the INVITE as a UAC + 'proxy-uac': the server is forwarding an INVITE as a proxy + 'proxy-uas': the server is receiving an INVITE as a proxy * reason : the termination reason for the call + 'call-rejected': the INVITE was rejected with a non-success final status + 'call-canceled': the INVITE was canceled by the sender before answer + 'normal-release': the call was connected and later released normally by one side or the other + 'session-expired': the call was connected and later torn down by the drachtio server because the session expired * msg : + for 'cdr:attempt', the INVITE request + for 'cdr:start', the 200 OK + for 'cdr:stop', the final non-success response (if reason is 'call-rejected'), otherwise the BYE request taht was sent or received to terminate the Dialog. Further information about the call, such as calling and called party numbers, can be retrieved from the msg parameter using the properties and methods of the SIP Message object . Note: an application that wishes to receive CDR events must establish an inbound connection to the drachtio server, since CDR events are not currently sent over outbound connections.","title":"Call Detail Records"},{"location":"developer-guide/introduction/","text":"Introduction Getting your kit up and running drachtio-srf (the 'srf' stands for S ignaling R esource F ramework) is the npm module that you will add to your package.json to build SIP server applications using drachtio. drachtio-srf works in concert with a drachtio server process to control and manage SIP calls and events. So you will need a running instance of a drachtio server somewhere to connect to in order to start developing. You can find instructions for building a drachtio server from scratch here , or if you prefer ansible you can find an ansible role here , but the easiest way to get started is probably to run a docker image . Review the drachtio server docs for detailed information on configuring the server. Notes: The sample code below assumes that a drachtio server process is running on the localhost and is listening for connections from applications on port 9021 (tcp). Let's do something simple Let's write a simple app that receives an INVITE and responds with a 486 status with a custom reason. First, create a new application and add drachtio-srf as a dependency: $ mkdir reject-nice cd $_ $ npm init ...follow prompts, enter 'app.js' for entry point $ touch app.js $ npm install --save drachtio-srf Next, make your app.js to look like this: const Srf = require('drachtio-srf'); const srf = new Srf(); srf.connect({ host: '127.0.0.1', port: 9021, secret: 'cymru' }); srf.on('connect', (err, hostport) = { console.log(`connected to a drachtio server listening on: ${hostport}`); }); srf.invite((req, res) = { res.send(486, 'So sorry, busy right now', { headers: { 'X-Custom-Header': 'because why not?' } }); }); Now start your drachtio server or docker image -- in the example above the drachtio server is running locally and listening on the localhost address with default port and secret. Once the drachtio server is running, start your app and verify it connects: $ node app.js connected to a drachtio server listening on: tcp/[::1]:5060,udp/[::1]:5060, \\ tcp/127.0.0.1:5060,udp/127.0.0.1:5060,tcp/192.168.200.135:5060,udp/192.168.200.135:5060 Now fire up a sip client of some kind (e.g. Bria , Blink , or other), point it at the address your drachtio server is listening on, and place a call. If everything is communicating properly, the call will get rejected with the reason above and in the drachtio log you should see the SIP trace, including the generated response: 2018-05-05 13:31:02.879056 send 358 bytes to udp/[127.0.0.1]:57296 at 13:31:02.878925: SIP/2.0 486 So sorry, busy right now Via: SIP/2.0/UDP 127.0.0.1:57296;branch=z9hG4bK-524287-1---de4c69061049b867;rport=57296 From: sip:dhorton@sip.drachtio.org ;tag=5fac7d01 To: sip:22@sip.drachtio.org ;tag=KjH30DtKFKXcQ Call-ID: 89373MWI0ODM1YTc2MTc2NThlZDE0MTU1YmRmNDY5OTk0NzM CSeq: 1 INVITE Content-Length: 0 X-Custom-Header: because why not? What did we just do? OK, so rejecting an incoming call is not particularly exciting, but the main thing we just accomplished was to verify that we have a working drachtio server, and also we illustrated how to connect an application to a drachtio server. The type of connection made in our example above is called an inbound connection; that is, a TCP connection made from the nodejs application acting as a client to the drachtio server process acting as the server. There is also the possibility of having the drachtio server make an outbound connection to a listening application, but that is a more advanced topic we will cover later , along with the reasons on why you might want to do that. By default, the drachtio server process listens for inbound connections on tcp port 9021, but this can be configured to a different port in its configuration file. Authentication is currently performed using a simple plaintext secret, which is also configured in the drachtio server configuration file. In the example above, we listened for the 'connect' event on the srf object. However, it is a best practice to also listen for the error event, e.g.: srf .on('connect', (err, hostport) = { console.log(`connected to a drachtio server listening on: ${hostport}`); }) .on('error', (err) = { console.log(`Error connecting to drachtio server: ${err}`); }); The reason for this is that if (and only if) your app has an error handler on the srf instance, the framework will automatically try to reconnect any time the connection is lost, which is generally what you want in production scenarios. Pro tip: always have an error handler on your Srf instance when using inbound connections, so your application will automatically reconnect to the server if the tcp connection is dropped. Where did those other SIP headers come from? Notice that although our application only provided one SIP header (a custom 'X-' header), the response actually sent by the drachtio server was a normal, fully-formed SIP response. This is because the drachtio server process does a lot of the heavy lifting for us when it comes to managing the low-level SIP messaging. Our applications generally do not need to specify values for the common SIP headers, unless for some reason we want to override the behavior of the drachtio server. By the way, the custom header was, of course, not really necessary and was only done for illustrative purposes in the example above. Neither, for that matter, was the SIP reason we provided: we could have simply sent a standard SIP/2.0 486 Busy Here with the following line of code: res.send(486); And, by the way, we are not limited to adding custom SIP headers to our messages -- we can add standard SIP headers in the same way: res.send(486, { headers, { 'Subject' : 'my first app' } });","title":"introduction"},{"location":"developer-guide/introduction/#introduction","text":"","title":"Introduction"},{"location":"developer-guide/introduction/#getting-your-kit-up-and-running","text":"drachtio-srf (the 'srf' stands for S ignaling R esource F ramework) is the npm module that you will add to your package.json to build SIP server applications using drachtio. drachtio-srf works in concert with a drachtio server process to control and manage SIP calls and events. So you will need a running instance of a drachtio server somewhere to connect to in order to start developing. You can find instructions for building a drachtio server from scratch here , or if you prefer ansible you can find an ansible role here , but the easiest way to get started is probably to run a docker image . Review the drachtio server docs for detailed information on configuring the server. Notes: The sample code below assumes that a drachtio server process is running on the localhost and is listening for connections from applications on port 9021 (tcp).","title":"Getting your kit up and running"},{"location":"developer-guide/introduction/#lets-do-something-simple","text":"Let's write a simple app that receives an INVITE and responds with a 486 status with a custom reason. First, create a new application and add drachtio-srf as a dependency: $ mkdir reject-nice cd $_ $ npm init ...follow prompts, enter 'app.js' for entry point $ touch app.js $ npm install --save drachtio-srf Next, make your app.js to look like this: const Srf = require('drachtio-srf'); const srf = new Srf(); srf.connect({ host: '127.0.0.1', port: 9021, secret: 'cymru' }); srf.on('connect', (err, hostport) = { console.log(`connected to a drachtio server listening on: ${hostport}`); }); srf.invite((req, res) = { res.send(486, 'So sorry, busy right now', { headers: { 'X-Custom-Header': 'because why not?' } }); }); Now start your drachtio server or docker image -- in the example above the drachtio server is running locally and listening on the localhost address with default port and secret. Once the drachtio server is running, start your app and verify it connects: $ node app.js connected to a drachtio server listening on: tcp/[::1]:5060,udp/[::1]:5060, \\ tcp/127.0.0.1:5060,udp/127.0.0.1:5060,tcp/192.168.200.135:5060,udp/192.168.200.135:5060 Now fire up a sip client of some kind (e.g. Bria , Blink , or other), point it at the address your drachtio server is listening on, and place a call. If everything is communicating properly, the call will get rejected with the reason above and in the drachtio log you should see the SIP trace, including the generated response: 2018-05-05 13:31:02.879056 send 358 bytes to udp/[127.0.0.1]:57296 at 13:31:02.878925: SIP/2.0 486 So sorry, busy right now Via: SIP/2.0/UDP 127.0.0.1:57296;branch=z9hG4bK-524287-1---de4c69061049b867;rport=57296 From: sip:dhorton@sip.drachtio.org ;tag=5fac7d01 To: sip:22@sip.drachtio.org ;tag=KjH30DtKFKXcQ Call-ID: 89373MWI0ODM1YTc2MTc2NThlZDE0MTU1YmRmNDY5OTk0NzM CSeq: 1 INVITE Content-Length: 0 X-Custom-Header: because why not?","title":"Let's do something simple"},{"location":"developer-guide/introduction/#what-did-we-just-do","text":"OK, so rejecting an incoming call is not particularly exciting, but the main thing we just accomplished was to verify that we have a working drachtio server, and also we illustrated how to connect an application to a drachtio server. The type of connection made in our example above is called an inbound connection; that is, a TCP connection made from the nodejs application acting as a client to the drachtio server process acting as the server. There is also the possibility of having the drachtio server make an outbound connection to a listening application, but that is a more advanced topic we will cover later , along with the reasons on why you might want to do that. By default, the drachtio server process listens for inbound connections on tcp port 9021, but this can be configured to a different port in its configuration file. Authentication is currently performed using a simple plaintext secret, which is also configured in the drachtio server configuration file. In the example above, we listened for the 'connect' event on the srf object. However, it is a best practice to also listen for the error event, e.g.: srf .on('connect', (err, hostport) = { console.log(`connected to a drachtio server listening on: ${hostport}`); }) .on('error', (err) = { console.log(`Error connecting to drachtio server: ${err}`); }); The reason for this is that if (and only if) your app has an error handler on the srf instance, the framework will automatically try to reconnect any time the connection is lost, which is generally what you want in production scenarios. Pro tip: always have an error handler on your Srf instance when using inbound connections, so your application will automatically reconnect to the server if the tcp connection is dropped.","title":"What did we just do?"},{"location":"developer-guide/introduction/#where-did-those-other-sip-headers-come-from","text":"Notice that although our application only provided one SIP header (a custom 'X-' header), the response actually sent by the drachtio server was a normal, fully-formed SIP response. This is because the drachtio server process does a lot of the heavy lifting for us when it comes to managing the low-level SIP messaging. Our applications generally do not need to specify values for the common SIP headers, unless for some reason we want to override the behavior of the drachtio server. By the way, the custom header was, of course, not really necessary and was only done for illustrative purposes in the example above. Neither, for that matter, was the SIP reason we provided: we could have simply sent a standard SIP/2.0 486 Busy Here with the following line of code: res.send(486); And, by the way, we are not limited to adding custom SIP headers to our messages -- we can add standard SIP headers in the same way: res.send(486, { headers, { 'Subject' : 'my first app' } });","title":"Where did those other SIP headers come from?"},{"location":"developer-guide/middleware/","text":"Middleware drachtio-srf is a middleware framework. As we saw above, we handle SIP INVITEs using srf.invite(handler) where our handler function is invoked with (req, res) and the arguments provided are objects that represent the incoming SIP request and the SIP response the application will send, respectively. All of the SIP methods are routed similarly, e.g. srf.register((req, res) = {...handle REGISTERs}); srf.options((req, res) = {...handle OPTIONS}); srf.subscribe((req, res) = {...handle SUBSCRIBE}); //...etc drachtio middleware can also be installed via the .use method. The middleware can be globally applied to all requests, or can be scoped by method. Below is an example where we use global middleware to log all requests, and a second middleware that parses authentication credentials from incoming REGISTER requests. const Srf = require('drachtio-srf'); const srf = new Srf(); const registrationParser = require('drachtio-mw-registration-parser'); srf.use((req, res, next) = console.log(`incoming ${req.method from ${req.source_address}}`)); srf.use('register', registrationParser); srf.register((req, res) = { // middleware has populated req.registration console.log(`registration info: ${req.registration}); // { // type: 'register' or 'unregister' // expires: expires value in either Contact or Expires header // contact: sip contact / address to send requests to // aor: address-of-record being registered // } ; }); Example middleware include: * drachtio-mw-digest-auth - implements server-side digest authentication, per RFC 2617 * drachtio-mw-registration-parser","title":"middleware"},{"location":"developer-guide/middleware/#middleware","text":"drachtio-srf is a middleware framework. As we saw above, we handle SIP INVITEs using srf.invite(handler) where our handler function is invoked with (req, res) and the arguments provided are objects that represent the incoming SIP request and the SIP response the application will send, respectively. All of the SIP methods are routed similarly, e.g. srf.register((req, res) = {...handle REGISTERs}); srf.options((req, res) = {...handle OPTIONS}); srf.subscribe((req, res) = {...handle SUBSCRIBE}); //...etc drachtio middleware can also be installed via the .use method. The middleware can be globally applied to all requests, or can be scoped by method. Below is an example where we use global middleware to log all requests, and a second middleware that parses authentication credentials from incoming REGISTER requests. const Srf = require('drachtio-srf'); const srf = new Srf(); const registrationParser = require('drachtio-mw-registration-parser'); srf.use((req, res, next) = console.log(`incoming ${req.method from ${req.source_address}}`)); srf.use('register', registrationParser); srf.register((req, res) = { // middleware has populated req.registration console.log(`registration info: ${req.registration}); // { // type: 'register' or 'unregister' // expires: expires value in either Contact or Expires header // contact: sip contact / address to send requests to // aor: address-of-record being registered // } ; }); Example middleware include: * drachtio-mw-digest-auth - implements server-side digest authentication, per RFC 2617 * drachtio-mw-registration-parser","title":"Middleware"},{"location":"developer-guide/sip-dialogs/","text":"SIP Dialogs Conceptually, a SIP dialog is defined in RFC 3261 as a relationship between two SIP endpoints that persists for a period time. Generally speaking, we are referring most often to a multimedia call initiated by a SIP INVITE transaction during which audio and/or video is exchanged. (Later we will discuss an alternative type of dialog created by a SUBSCRIBE transaction). Within drachtio, A SIP dialog is an object that is created to represent a multimedia session and to allow a developer to manage such sessions: to create them, modify them, and tear them down. The examples we have shown till now have illustrated how to manage SIP interactions at the SIP message level. However, in most cases the drachtio SIP Dialog API provides a higher-level abstraction that makes it easier for developers to manage sessions. User Roles in a Dialog Some basic terminology is going to be helpful before diving into the API and some examples. A drachtio application can: * initiate an INVITE transaction -- in which case we say it is acting as a 'User Agent Client', or UAC, * respond to an incoming INVITE transaction -- in which case we call it a 'User Agent Server', or UAS, and/or * both receive and send an INVITE transaction -- in which case we call it a 'back to back User Agent', or B2BUA By the way, these are not the only types of applications we can build with drachtio. We can also build: * a registar -- which is an application that responds to REGISTER requests * a presence server -- which is an application that responds to SUBSCRIBE requests * an instant messaging server -- which responds to MESSAGE requests ( see here for an example of a presence and messaging server) * a sip proxy -- which is an application that routes and forwards SIP requests Quite frequently, though, we will find ourselves wanting to build some form of SIP User Agent application, and that is what we will cover in this section. The dialog API consists of the methods * Srf#createUAS , * Srf#createUAC , and * Srf#createB2BUA . Each of these methods produces a Dialog object when a session is successfully established, which is returned via a callback (if provided) and resolves the Promise returned by each of the above methods. Before we review the above three methods, let's examine the Dialog class itself, and how to work with it. Dialog The Dialog class is an event emitter, and has the following properties, methods, and events. properties sip : an object containing properties that identify the SIP dialog sip.callId : the SIP Call-Id associated with this dialog sip.remoteTag : the remote tag associated with the dialog sip.localTag : the local tag associated with the dialog local : an object containing properties associated with the local end of the dialog local.sdp : the local session description protocol local.uri : the local sip uri local.contact : the local contact remote : an object containing properties associated with the remote end of the dialog remote.sdp : the remote session description protocol remote.uri : the remote sip uri remote.contact : the local contact id : a unique identifier for the dialog with the drachtio framework dialogType : either 'INVITE' or 'SUBSCRIBE' methods destroy(opts, callback) : terminates a dialog, by sending a BYE (in the case of an INVITE dialog), or a NOTIFY with Subscription-State: terminated (in the case of a SUBSCRIBE dialog). modify(sdp, callback) : modifies a SIP INVITE dialog by putting it on or off hold or re-INVITing to a new session description protocol. request(opts, callback) : sends a SIP request within a dialog. events destroy(req) : emitted when the remote end has terminated the dialog. The req parameter represents the SIP request sent from the remote end to terminate the dialog. (Note: no action is required by the application, as the drachtio server will have sent a 200 OK to the request). hold(req) : emitted when the remote end has placed the call on hold. The req parameter represents the INVITE on hold sent. (Note: no action is required by the application, as the drachtio server will have sent a 200 OK to the request). modify(req,res) : emitted when the remote end has sent a re-INVITE with a changed session description protocol. The application must respond, using the res parameter provided. refresh(req) : emitted when the remote end has sent a refreshing re-INVITE. (Note: no action is required by the application, as the drachtio server will have sent a 200 OK to the request). unhold(req) : emitted when the remote end has taken the call off hold. The req parameter represents the INVITE off hold sent. (Note: no action is required by the application, as the drachtio server will have sent a 200 OK to the request). info(req, res) messsage(req, res) options(req, res) publish(req, res) refer(req, res) subscribe(req, res) update(req, res) : these and the above events are emitted when a SIP request of the specified type is received within a dialog. The application must respond, using the res parameter provided. If the application does not have a listener registered for the event, then the drachtio server will automatically respond with a 200 OK. Pro tip: while there are many operations you might want to perform on a Dialog object, the one thing you should always do is to listen for the 'destroy' event. You should attach a listener for 'destroy' whenever you create a new dialog. This will tell you when the remote side has hung up, and after this you will no longer be able to operate on the dialog. UAS Whew! With that background under our belt we can finally get to the meat of the matter -- creating and managing calls. When we receive an incoming call and connect it to an IVR, or to a conference bridge, our application is acting as a UAS. Let's look at these scenarios first. The one piece of information we need when acting as a UAS is the session description protocol (sdp) that we want to offer in our 200 OK. Creating media endpoints is outside the scope of drachtio-srf, so the examples below assume that our application has obtained them through other means. Note: check out drachtio-fsmrf , which is a npm module that can be used with drachtio-srf to control media resources on a Freeswitch media server in order to provide IVR and conferencing features to drachtio applications. srf.invite((req, res) = { let sdp = 'some-session-description-protocol' srf.createUAS(req, res, { localSdp: sdp }) .then((dialog) = { console.log('successfully created UAS dialog'); dialog.on('destroy', () = console.log('remote party hung up')); }) .catch((err) = { console.log(`Error creating UAS dialog: ${err}`); }) ; }); In the example above, the local sdp is provided as a string, but we can alternatively provide a function that returns a Promise which resolves to a string value representing the session description protocol. This is useful when we have to perform some sort of asynchronous operation to obtain the sdp. function getMySdp() { return doSomeNetworkOperation() .then((results) = { return results.sdp; }); } srf.invite((req, res) = { let sdp = 'some-session-description-protocol' srf.createUAS(req, res, { localSdp: getMySdp }) .then((dialog) = { .. }) .catch((err) = { .. }); }); Of course, we can supply SIP headers in the usual manner: srf.invite((req, res) = { srf.createUAS(req, res, { localSdp: sdp, headers: { 'User-Agent': 'drachtio/iechyd-da', 'X-Linked-UUID': '1e2587c' } }) .then((dialog) = { .. }); }); If Srf#createUAS fails to create a dialog for some reason, an error object will be returned via either callback or the Promise. If the failure is due to a SIP non-success status code, then a SipError will be returned. In the UAS scenario, the only time this will happen is if the call is canceled by the caller before we answer it, in which case a '487 Request Terminated' will be the final SIP status. srf.invite((req, res) = { srf.createUAS(req, res, { localSdp: sdp, headers: { 'User-Agent': 'drachtio/iechyd-da', 'X-Linked-UUID': '1e2587c' } }) .then((dialog) = { .. }) .catch((err) = { if (err instanceof Srf.SipError err.status === 487) { console.log('call canceled by caller'); } }) Finally, as noted above, Srf#createUAS can be invoked with a callback as an alternative to Promises. In most of the examples in this document we will use Promises, but an example of using a callback is presented below. srf.invite((req, res) = { let sdp = 'some-session-description-protocol' srf.createUAS(req, res, { localSdp: sdp }, (err, dialog) = { if (err) console.log(`Error creating UAS dialog: ${err}`); else { console.log('successfully created UAS dialog'); dialog.on('destroy', () = console.log('remote party hung up')); } }); }); UAC When we initiate a dialog by sending an INVITE, we are acting as a UAC. We use the Srf#createUAC method to accomplish this. Just as with Srf#createUAS , either a callback approach or a Promise-based approach is supported. In the simplest example, we can provide only the Request-URI we want to send to, and the session description protocol we are offering in the INVITE in that example: let mySdp; // populated somehow with SDP we want to offer srf.createUac('sip:1234@10.10.100.1', {localSdp: mySdp}) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); }); Pro tip: we can specify the Request-Uri either a full sip uri, as above, or simply provide an ip address (or ip address:port, if we want to send to a non-default SIP port). What did drachtio server do in all this? In the example above, we supplied only the Request-URI and body of the INVITE, so the drachtio server must have done quite a bit in terms of filling out the rest of the message and managing various aspects of the transaction. In fact, the drachtio server would have done all of the following to create the outgoing INVITE: * generated a (unique) SIP Call-ID and a CSeq * generated the appropriate Via header (pro tip: never provide a Via: header, always let drachtio generate that) * generated the From header (with no user element in the URI), and generated a From tag * generated the To header (according to the Request-URI we provided) * generated a Contact header, based on the Request-URI and the address:port(s) that the server is listening on for SIP messages * examined the body that we provided and -- seeing that it was an sdp -- created a Content-Type of 'application/sdp' * calculated the Content-Length header (pro tip: never provide a Content-Length: header, always let drachtio generate that) It would have then sent the INVITE, and managed any provisional and final responses. It would have generated the final ACK request as well. If a reliable provisional response were received, it would have responded with the required PRACK request. Beyond this basic usage, there are several other common patterns. Let's look at some of them. Receiving provisional responses When we send out an INVITE, we may get some provisional (1XX) responses back before we get a final response. In the example above, we did not care to do anything with these provisional responses, but if we want to receive them we can add a callback that will be invoked when we receive a provisional response. This callback, named cbProvisional , along with another we will describe shortly, are provided in an optional Object parameter as shown below. srf.createUac('sip:1234@10.10.100.1', {localSdp: mySdp}, { cbProvisional: (res) = console.log(`got provisional response: ${res.status}`)) }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err.status}`); }); Note: if the INVITE fails, a SipError object will be returned, and the final SIP non-success status can be retrieved from err.status as shown above. Canceling an INVITE we sent Sometimes, we may want to cancel an INVITE that we have sent before it is answered. Related to this, we may simply want to get access to details of the actual INVITE that was sent out over the wire. To do this, we can provide a cbRequest callback in the callback object mentioned above. This callback receives a req object representing the INVITE that was sent over the wire. If we later want to cancel the INVITE, we simply call req.cancel() . let invite, dlg; srf.createUac('sip:1234@10.10.100.1', {localSdp: mySdp}, { cbRequest: (err, req) = invite = req), cbProvisional: (res) = console.log(`got provisional response: ${res.status}`)) }) .then((dialog) = { dlg = dialog dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}`); }); someEmitter.on('some-event', () = { // something happened to make us want to cancel the call if (!dlg invite) invite.cancel(); }); Authentication If we send an INVITE that is challenged (with either a 401 Unauthorized or a 407 Proxy Authentication Required), we can have the drachtio framework handle this if we provide the username and password in the opts.auth parameter: let mySdp; // populated somehow with SDP we want to offer srf.createUac('sip:1234@10.10.100.1', { localSdp: mySdp, auth: { username: 'dhorton', password: 'foobar' } }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); }); Sending through an outbound SIP proxy If we want the INVITE to be sent through an outbound SIP proxy, rather than directly to the endpoint specified in the Request-URI, we can specify an opts.proxy parameter: let mySdp; // populated somehow with SDP we want to offer srf.createUac('sip:1234@10.10.100.1', { localSdp: mySdp, proxy: 'sip:proxy.enterprise.com' }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); }); Specifying calling number or called number If we want to specify the calling party number to use in the From header of the INVITE, and/or the called party number to use in the To header as well as the Request-URI, we can do so simply like this: let mySdp; // populated somehow with SDP we want to offer srf.createUac('sip:1234@10.10.100.1', { localSdp: mySdp, callingNumber: '+18584083089', calledNumber: '+15083345988' }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); }); Pro tip: Where possible, use this approach of providing 'opts.callingNumber' rather than trying to provide a full From header. Pro tip: If you really want to provide the full From header, for the host part of the uri use the string 'localhost'. The drachtio server will handle this by replacing the host value with the proper IP address for the server. Sending a 3PCC INVITE A scenario known as third-party call control (3PCC) occurs when a UAC sends an INVITE with no body -- i.e., no session description protocol is initially offered. In this call flow, after the offer is received in the 200 OK response from the B party, the UAC sends its sdp in the ACK to establish the media flows. To accomplish this, the Srf#createUAC can be used. However, because of the need to specify an SDP in the ACK, the application must take additional responsibility for generating the ACK. Furthermore, instead of delivering a Dialog, the Promise (or callback) will render an object containing two properties: * sdp : the sdp received in the 200 OK from the B party, and * ack : a function that the application must call, providing the SDP to be included in the ACK as the first parameter. The function returns a Promise that resolves to the Dialog created by the ACK. With that as background, let's see an example: srf.createUac('sip:1234@10.10.100.1', { callingNumber: '+18584083089', calledNumber: '+15083345988', noAck: true }) .then((obj) = { console.log(`received sdp offer ${obj.sdp} from B party`); let mySdp = allocateSdpSomehow(); return obj.ack(mySdp); }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); }); Note a few things in this example: * There was no opts.body parameter in the call to Srf#createUAC : the absence of a body signals the drachtio framework that we are intending a 3PCC scenario. * The use of opts.noAck indicates that we do not want the framework to generate the ACK for us, and that instead we will explicitly call the obj.ack() function to take responsibility for that. There is also a fairly common alternative 3PCC special case where you may want to offer a \"null\" SDP in the ACK, i.e. creating an initially inactive media stream that you will later activate with a re-INVITE. In that case, you can simply remove the opts.noAck parameter and the Promise/callback will deliver the completed dialog as in the normal case -- the framework will generate the appropriate \"null\" sdp and generate the ACK for you. srf.createUac('sip:1234@10.10.100.1', { callingNumber: '+18584083089', calledNumber: '+15083345988' }) .then((dialog) = { console.log(`created dialog with inactive media`); dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); }); B2BUA When we receive an incoming INVITE (the A leg), and then send a new outgoing INVITE on a different SIP transaction (the B leg), we are acting as a back to back user agent. We use the Srf#createB2BUA method to accomplish this. Once again, either a callback approach or a Promise-based approach is supported. As with the UAC scenario, the simplest usage is to provide the Request-URI to send the B leg to and the sdp to offer on the B leg. If successful, our application receives two SIP dialogs: a UAS dialog (the A leg) and a UAC dialog (the B leg); srf.invite((req, res) = { srf.createB2BUA(req, res, 'sip:1234@10.10.100.1', {localSdpB: req.body}) .then({uas, uac} = { console.log('call successfully connected'); // when one side hangs up, we hang up the other uas.on('destroy', () = uac.destroy()); uac.on('destroy', () = uas.destroy()); }) .catch((err) = console.log(`call failed to connect: ${err}`)); }); Beyond this simple example, there are many options. Let's look at some of them: Copying headers from the A leg onto the B leg It's quite common for us to want to include on the B leg INVITE some of the headers that we received on the A leg; vice-versa, we may want to include on the A leg response some of the headers that we received on the B leg response. This can be achieved with the opts.proxyRequestHeaders and the opts.proxyResponseHeaders properties in the optional opts parameter. If provided, these should include an array of header names that should be copied from one to the other. The example below illustrates a B2BUA app that wants to pass authentication headers between endpoints srf.invite((req, res) = { srf.createB2BUA(req, res, 'sip:1234@10.10.100.1' { localSdpB: req.body, proxyRequestHeaders: ['Proxy-Authorization', 'Authorization'], proxyResponseHeaders: ['WWW-Authenticate', 'Proxy-Authentication'] }) .then({uas, uac} = { console.log('call successfully connected'); // when one side hangs up, we hang up the other uas.on('destroy', () = uac.destroy()); uac.on('destroy', () = uas.destroy()); }) .catch((err) = console.log(`call failed to connect: ${err}`)); }); Obtaining the UAC dialog as soon as possible When the Srf#createB2BUA completes successfully, it provides us the two dialog that have been established. However, in rare cases it may be desirable to receive the UAC dialog as soon as it is established -- that is, as soon as we have received a 200 OK from the B party, before we have sent the 200 OK back to the A party, and before the Srf#createB2BUA](/docs/api#Srf+createB2BUA) method has resolved the Promise that it returns. For this need, similar to Srf#createUAC , there is an optional callback object that contains a callback named cbFinalizedUac that, if provided, is invoked with the UAC dialog as soon as it is created. (Note: the cbProvisional and cbRequest callbacks are also available). srf.invite((req, res) = { srf.createB2BUA(req, res, 'sip:1234@10.10.100.1', { localSdpB: req.body }, { cbFinalizedUac: (uac) = { console.log(`successfully connected to B party at ${uac.remote.contact}`); } }) .then({uas, uac} = { console.log('call successfully connected'); // when one side hangs up, we hang up the other uas.on('destroy', () = uac.destroy()); uac.on('destroy', () = uas.destroy()); }) .catch((err) = console.log(`call failed to connect: ${err}`)); }); Modifying SDP offered to A leg in SIP response By default, Srf#createUAC will respond with a 200 OK to the A leg INVITE with the sdp that it received from the B party in the 200 OK on the B leg. In other words, it simply proxies the session description protocol offer from B back to A. Sometimes, however, it is desirable to transform or modify the SDP received on the B leg before sending it back on the A leg. For this purpose, the opts.localSdpA parameter is available. This parameter can either be a string, containing the sdp to offer in the 200 OK back to the A leg, or it can be a function returning a Promise that resolves to the sdp to return in the 200 OK to the A leg. The function has the signature (sdpB, res) , where sdpB is the session description offer we received in the 200 OK from the B party, and res is the response object we received on the B leg. Rather than include an example here, please refer to the source code for the drachtio-b2b-media-proxy application, which is a simple B2BUA that uses rtpengine to proxy the media. This is a great example of when you would want to transform the SDP from B before returning the final session description offer to A. Choosing not to propagate failure from B leg By default, if we get a final SIP non-success from the B party it will be propagated back to the A party. There are times where we would prefer not to do so; for instance, if having failed to connect the A party to one endpoint or phone number, we would now wish to try another. Setting opts.passFailure to value of false enables this behavior. srf.invite((req, res) = { srf.createB2BUA(req, res, 'sip:1234@10.10.100.1', {localSdpB: req.body, passFailure: false}) .then({uas, uac} = { console.log('call connected to primary destination'); }) .catch((err) = { // try backup if we got a sip non-success response and the caller did not hang up if (err.status !== 487) { console.log(`failed connecting to primary, will try backup: ${err}`); srf.createB2BUA(req, res, 'sip:1234@10.10.100.2', { localSdpB: req.body} }) .then({uas, uac} = { console.log('call connected to backup destination'); }) catch((err) = { console.log(`failed connecting to backup uri: ${err}`); }); } }); }); Note that we had to check that the reason for the failure connecting our first attempt was not a 487 Request Cancelled, because this is the error we receive when the caller (A party) hung up before we connected the B party. In that case, we no longer would want to attempt a backup destination. This also answers a related question you may have had: what happens when the A part hangs up before connected, and does our app need to do anything specifically to cancel the B leg when the A leg cancels? The answer to the latter is no, the drachtio framework will automatically cancel the B leg if the A leg is canceled. Subscribe Dialogs SUBSCRIBE requests also establish SIP Dialogs, as per RFC 3265 . A UAC (the subscriber ) sends a SUBSCRIBE request with an Event header indicating the event that is being subscribed to, and the UAS (the notifier ) responds with a 202 Accepted response. The UAS should then immediately send a NOTIFY to the UAC of the current state of the requested resource. To terminate a SUBSCRIBE dialog, the UAS sends a NOTIFY request with Subscription-State: terminated; while a UAC would send another SUBSCRIBE with an Expires: 0. The dialog produced by the Srf#createUAS method will be a SUBSCRIBE dialog if the request was a SUBSCRIBE. While the Srf#createUAS method call will send a 202 Accepted, it does not send the initial NOTIFY request that should follow -- the application must do that, since the content can only be determined by the application itself. srf.subscribe((req, res) = { srf.createUAS(req, res, { { headers: {'Expires': req.get('Expires') } }) .then((dialog) = { dialog.on('destroy', () = console.log('remote party terminated dialog')); // send initial NOTIFY let myContent = 'some content reflecting current resource state..'; return dialog.request({ method: 'NOTIFY', headers: { 'Subscription-State': 'active', 'Event': req.get('Event'), 'Content-Type': 'application/pidf+xml' // or whatever }, body: myContent }); }); }); Pro tip: If you need to query a dialog to see whether it is an INVITE or a SUBSCRIBE dialog, you can use the dialogType (read-only) property of the Dialog object to determine that. The Srf#createUAC method can also be used to generate a SUBSCRIBE dialog as a UAC/subscriber. To do this, specify opts.method should be set to 'SUBSCRIBE'. srf.createUac('sip:resource@example.com', { method: 'SUBSCRIBE', headers: { 'From': ' sip:user@locahost ', 'Event': 'presence', 'Expires': 3600 } }) .then((dialog) = { dialog.on('destroy', () = console.log('remote party ended dialog')); dialog.on('notify', (req, res) = { res.send(200); console.log(`received NOTIFY for event ${req.get('Event')}`); if (req.body) { console.log(`received content of type ${req.get('Content-Type')}: ${req.body}`); } }); }); Note in the example above the use of 'localhost' as the host part of the uri of the From header. As mentioned earlier, this will cause the drachtio server to replace this with the appropriate IP address of the server.","title":"sip dialogs"},{"location":"developer-guide/sip-dialogs/#sip-dialogs","text":"Conceptually, a SIP dialog is defined in RFC 3261 as a relationship between two SIP endpoints that persists for a period time. Generally speaking, we are referring most often to a multimedia call initiated by a SIP INVITE transaction during which audio and/or video is exchanged. (Later we will discuss an alternative type of dialog created by a SUBSCRIBE transaction). Within drachtio, A SIP dialog is an object that is created to represent a multimedia session and to allow a developer to manage such sessions: to create them, modify them, and tear them down. The examples we have shown till now have illustrated how to manage SIP interactions at the SIP message level. However, in most cases the drachtio SIP Dialog API provides a higher-level abstraction that makes it easier for developers to manage sessions.","title":"SIP Dialogs"},{"location":"developer-guide/sip-dialogs/#user-roles-in-a-dialog","text":"Some basic terminology is going to be helpful before diving into the API and some examples. A drachtio application can: * initiate an INVITE transaction -- in which case we say it is acting as a 'User Agent Client', or UAC, * respond to an incoming INVITE transaction -- in which case we call it a 'User Agent Server', or UAS, and/or * both receive and send an INVITE transaction -- in which case we call it a 'back to back User Agent', or B2BUA By the way, these are not the only types of applications we can build with drachtio. We can also build: * a registar -- which is an application that responds to REGISTER requests * a presence server -- which is an application that responds to SUBSCRIBE requests * an instant messaging server -- which responds to MESSAGE requests ( see here for an example of a presence and messaging server) * a sip proxy -- which is an application that routes and forwards SIP requests Quite frequently, though, we will find ourselves wanting to build some form of SIP User Agent application, and that is what we will cover in this section. The dialog API consists of the methods * Srf#createUAS , * Srf#createUAC , and * Srf#createB2BUA . Each of these methods produces a Dialog object when a session is successfully established, which is returned via a callback (if provided) and resolves the Promise returned by each of the above methods. Before we review the above three methods, let's examine the Dialog class itself, and how to work with it.","title":"User Roles in a Dialog"},{"location":"developer-guide/sip-dialogs/#dialog","text":"The Dialog class is an event emitter, and has the following properties, methods, and events.","title":"Dialog"},{"location":"developer-guide/sip-dialogs/#properties","text":"sip : an object containing properties that identify the SIP dialog sip.callId : the SIP Call-Id associated with this dialog sip.remoteTag : the remote tag associated with the dialog sip.localTag : the local tag associated with the dialog local : an object containing properties associated with the local end of the dialog local.sdp : the local session description protocol local.uri : the local sip uri local.contact : the local contact remote : an object containing properties associated with the remote end of the dialog remote.sdp : the remote session description protocol remote.uri : the remote sip uri remote.contact : the local contact id : a unique identifier for the dialog with the drachtio framework dialogType : either 'INVITE' or 'SUBSCRIBE'","title":"properties"},{"location":"developer-guide/sip-dialogs/#methods","text":"destroy(opts, callback) : terminates a dialog, by sending a BYE (in the case of an INVITE dialog), or a NOTIFY with Subscription-State: terminated (in the case of a SUBSCRIBE dialog). modify(sdp, callback) : modifies a SIP INVITE dialog by putting it on or off hold or re-INVITing to a new session description protocol. request(opts, callback) : sends a SIP request within a dialog.","title":"methods"},{"location":"developer-guide/sip-dialogs/#events","text":"destroy(req) : emitted when the remote end has terminated the dialog. The req parameter represents the SIP request sent from the remote end to terminate the dialog. (Note: no action is required by the application, as the drachtio server will have sent a 200 OK to the request). hold(req) : emitted when the remote end has placed the call on hold. The req parameter represents the INVITE on hold sent. (Note: no action is required by the application, as the drachtio server will have sent a 200 OK to the request). modify(req,res) : emitted when the remote end has sent a re-INVITE with a changed session description protocol. The application must respond, using the res parameter provided. refresh(req) : emitted when the remote end has sent a refreshing re-INVITE. (Note: no action is required by the application, as the drachtio server will have sent a 200 OK to the request). unhold(req) : emitted when the remote end has taken the call off hold. The req parameter represents the INVITE off hold sent. (Note: no action is required by the application, as the drachtio server will have sent a 200 OK to the request). info(req, res) messsage(req, res) options(req, res) publish(req, res) refer(req, res) subscribe(req, res) update(req, res) : these and the above events are emitted when a SIP request of the specified type is received within a dialog. The application must respond, using the res parameter provided. If the application does not have a listener registered for the event, then the drachtio server will automatically respond with a 200 OK. Pro tip: while there are many operations you might want to perform on a Dialog object, the one thing you should always do is to listen for the 'destroy' event. You should attach a listener for 'destroy' whenever you create a new dialog. This will tell you when the remote side has hung up, and after this you will no longer be able to operate on the dialog.","title":"events"},{"location":"developer-guide/sip-dialogs/#uas","text":"Whew! With that background under our belt we can finally get to the meat of the matter -- creating and managing calls. When we receive an incoming call and connect it to an IVR, or to a conference bridge, our application is acting as a UAS. Let's look at these scenarios first. The one piece of information we need when acting as a UAS is the session description protocol (sdp) that we want to offer in our 200 OK. Creating media endpoints is outside the scope of drachtio-srf, so the examples below assume that our application has obtained them through other means. Note: check out drachtio-fsmrf , which is a npm module that can be used with drachtio-srf to control media resources on a Freeswitch media server in order to provide IVR and conferencing features to drachtio applications. srf.invite((req, res) = { let sdp = 'some-session-description-protocol' srf.createUAS(req, res, { localSdp: sdp }) .then((dialog) = { console.log('successfully created UAS dialog'); dialog.on('destroy', () = console.log('remote party hung up')); }) .catch((err) = { console.log(`Error creating UAS dialog: ${err}`); }) ; }); In the example above, the local sdp is provided as a string, but we can alternatively provide a function that returns a Promise which resolves to a string value representing the session description protocol. This is useful when we have to perform some sort of asynchronous operation to obtain the sdp. function getMySdp() { return doSomeNetworkOperation() .then((results) = { return results.sdp; }); } srf.invite((req, res) = { let sdp = 'some-session-description-protocol' srf.createUAS(req, res, { localSdp: getMySdp }) .then((dialog) = { .. }) .catch((err) = { .. }); }); Of course, we can supply SIP headers in the usual manner: srf.invite((req, res) = { srf.createUAS(req, res, { localSdp: sdp, headers: { 'User-Agent': 'drachtio/iechyd-da', 'X-Linked-UUID': '1e2587c' } }) .then((dialog) = { .. }); }); If Srf#createUAS fails to create a dialog for some reason, an error object will be returned via either callback or the Promise. If the failure is due to a SIP non-success status code, then a SipError will be returned. In the UAS scenario, the only time this will happen is if the call is canceled by the caller before we answer it, in which case a '487 Request Terminated' will be the final SIP status. srf.invite((req, res) = { srf.createUAS(req, res, { localSdp: sdp, headers: { 'User-Agent': 'drachtio/iechyd-da', 'X-Linked-UUID': '1e2587c' } }) .then((dialog) = { .. }) .catch((err) = { if (err instanceof Srf.SipError err.status === 487) { console.log('call canceled by caller'); } }) Finally, as noted above, Srf#createUAS can be invoked with a callback as an alternative to Promises. In most of the examples in this document we will use Promises, but an example of using a callback is presented below. srf.invite((req, res) = { let sdp = 'some-session-description-protocol' srf.createUAS(req, res, { localSdp: sdp }, (err, dialog) = { if (err) console.log(`Error creating UAS dialog: ${err}`); else { console.log('successfully created UAS dialog'); dialog.on('destroy', () = console.log('remote party hung up')); } }); });","title":"UAS"},{"location":"developer-guide/sip-dialogs/#uac","text":"When we initiate a dialog by sending an INVITE, we are acting as a UAC. We use the Srf#createUAC method to accomplish this. Just as with Srf#createUAS , either a callback approach or a Promise-based approach is supported. In the simplest example, we can provide only the Request-URI we want to send to, and the session description protocol we are offering in the INVITE in that example: let mySdp; // populated somehow with SDP we want to offer srf.createUac('sip:1234@10.10.100.1', {localSdp: mySdp}) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); }); Pro tip: we can specify the Request-Uri either a full sip uri, as above, or simply provide an ip address (or ip address:port, if we want to send to a non-default SIP port).","title":"UAC"},{"location":"developer-guide/sip-dialogs/#what-did-drachtio-server-do-in-all-this","text":"In the example above, we supplied only the Request-URI and body of the INVITE, so the drachtio server must have done quite a bit in terms of filling out the rest of the message and managing various aspects of the transaction. In fact, the drachtio server would have done all of the following to create the outgoing INVITE: * generated a (unique) SIP Call-ID and a CSeq * generated the appropriate Via header (pro tip: never provide a Via: header, always let drachtio generate that) * generated the From header (with no user element in the URI), and generated a From tag * generated the To header (according to the Request-URI we provided) * generated a Contact header, based on the Request-URI and the address:port(s) that the server is listening on for SIP messages * examined the body that we provided and -- seeing that it was an sdp -- created a Content-Type of 'application/sdp' * calculated the Content-Length header (pro tip: never provide a Content-Length: header, always let drachtio generate that) It would have then sent the INVITE, and managed any provisional and final responses. It would have generated the final ACK request as well. If a reliable provisional response were received, it would have responded with the required PRACK request. Beyond this basic usage, there are several other common patterns. Let's look at some of them.","title":"What did drachtio server do in all this?"},{"location":"developer-guide/sip-dialogs/#receiving-provisional-responses","text":"When we send out an INVITE, we may get some provisional (1XX) responses back before we get a final response. In the example above, we did not care to do anything with these provisional responses, but if we want to receive them we can add a callback that will be invoked when we receive a provisional response. This callback, named cbProvisional , along with another we will describe shortly, are provided in an optional Object parameter as shown below. srf.createUac('sip:1234@10.10.100.1', {localSdp: mySdp}, { cbProvisional: (res) = console.log(`got provisional response: ${res.status}`)) }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err.status}`); }); Note: if the INVITE fails, a SipError object will be returned, and the final SIP non-success status can be retrieved from err.status as shown above.","title":"Receiving provisional responses"},{"location":"developer-guide/sip-dialogs/#canceling-an-invite-we-sent","text":"Sometimes, we may want to cancel an INVITE that we have sent before it is answered. Related to this, we may simply want to get access to details of the actual INVITE that was sent out over the wire. To do this, we can provide a cbRequest callback in the callback object mentioned above. This callback receives a req object representing the INVITE that was sent over the wire. If we later want to cancel the INVITE, we simply call req.cancel() . let invite, dlg; srf.createUac('sip:1234@10.10.100.1', {localSdp: mySdp}, { cbRequest: (err, req) = invite = req), cbProvisional: (res) = console.log(`got provisional response: ${res.status}`)) }) .then((dialog) = { dlg = dialog dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}`); }); someEmitter.on('some-event', () = { // something happened to make us want to cancel the call if (!dlg invite) invite.cancel(); });","title":"Canceling an INVITE we sent"},{"location":"developer-guide/sip-dialogs/#authentication","text":"If we send an INVITE that is challenged (with either a 401 Unauthorized or a 407 Proxy Authentication Required), we can have the drachtio framework handle this if we provide the username and password in the opts.auth parameter: let mySdp; // populated somehow with SDP we want to offer srf.createUac('sip:1234@10.10.100.1', { localSdp: mySdp, auth: { username: 'dhorton', password: 'foobar' } }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); });","title":"Authentication"},{"location":"developer-guide/sip-dialogs/#sending-through-an-outbound-sip-proxy","text":"If we want the INVITE to be sent through an outbound SIP proxy, rather than directly to the endpoint specified in the Request-URI, we can specify an opts.proxy parameter: let mySdp; // populated somehow with SDP we want to offer srf.createUac('sip:1234@10.10.100.1', { localSdp: mySdp, proxy: 'sip:proxy.enterprise.com' }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); });","title":"Sending through an outbound SIP proxy"},{"location":"developer-guide/sip-dialogs/#specifying-calling-number-or-called-number","text":"If we want to specify the calling party number to use in the From header of the INVITE, and/or the called party number to use in the To header as well as the Request-URI, we can do so simply like this: let mySdp; // populated somehow with SDP we want to offer srf.createUac('sip:1234@10.10.100.1', { localSdp: mySdp, callingNumber: '+18584083089', calledNumber: '+15083345988' }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); }); Pro tip: Where possible, use this approach of providing 'opts.callingNumber' rather than trying to provide a full From header. Pro tip: If you really want to provide the full From header, for the host part of the uri use the string 'localhost'. The drachtio server will handle this by replacing the host value with the proper IP address for the server.","title":"Specifying calling number or called number"},{"location":"developer-guide/sip-dialogs/#sending-a-3pcc-invite","text":"A scenario known as third-party call control (3PCC) occurs when a UAC sends an INVITE with no body -- i.e., no session description protocol is initially offered. In this call flow, after the offer is received in the 200 OK response from the B party, the UAC sends its sdp in the ACK to establish the media flows. To accomplish this, the Srf#createUAC can be used. However, because of the need to specify an SDP in the ACK, the application must take additional responsibility for generating the ACK. Furthermore, instead of delivering a Dialog, the Promise (or callback) will render an object containing two properties: * sdp : the sdp received in the 200 OK from the B party, and * ack : a function that the application must call, providing the SDP to be included in the ACK as the first parameter. The function returns a Promise that resolves to the Dialog created by the ACK. With that as background, let's see an example: srf.createUac('sip:1234@10.10.100.1', { callingNumber: '+18584083089', calledNumber: '+15083345988', noAck: true }) .then((obj) = { console.log(`received sdp offer ${obj.sdp} from B party`); let mySdp = allocateSdpSomehow(); return obj.ack(mySdp); }) .then((dialog) = { dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); }); Note a few things in this example: * There was no opts.body parameter in the call to Srf#createUAC : the absence of a body signals the drachtio framework that we are intending a 3PCC scenario. * The use of opts.noAck indicates that we do not want the framework to generate the ACK for us, and that instead we will explicitly call the obj.ack() function to take responsibility for that. There is also a fairly common alternative 3PCC special case where you may want to offer a \"null\" SDP in the ACK, i.e. creating an initially inactive media stream that you will later activate with a re-INVITE. In that case, you can simply remove the opts.noAck parameter and the Promise/callback will deliver the completed dialog as in the normal case -- the framework will generate the appropriate \"null\" sdp and generate the ACK for you. srf.createUac('sip:1234@10.10.100.1', { callingNumber: '+18584083089', calledNumber: '+15083345988' }) .then((dialog) = { console.log(`created dialog with inactive media`); dialog.on('destroy', () = console.log('called party ended call')); }) .catch((err) = { console.log(`call failed with ${err}); });","title":"Sending a 3PCC INVITE"},{"location":"developer-guide/sip-dialogs/#b2bua","text":"When we receive an incoming INVITE (the A leg), and then send a new outgoing INVITE on a different SIP transaction (the B leg), we are acting as a back to back user agent. We use the Srf#createB2BUA method to accomplish this. Once again, either a callback approach or a Promise-based approach is supported. As with the UAC scenario, the simplest usage is to provide the Request-URI to send the B leg to and the sdp to offer on the B leg. If successful, our application receives two SIP dialogs: a UAS dialog (the A leg) and a UAC dialog (the B leg); srf.invite((req, res) = { srf.createB2BUA(req, res, 'sip:1234@10.10.100.1', {localSdpB: req.body}) .then({uas, uac} = { console.log('call successfully connected'); // when one side hangs up, we hang up the other uas.on('destroy', () = uac.destroy()); uac.on('destroy', () = uas.destroy()); }) .catch((err) = console.log(`call failed to connect: ${err}`)); }); Beyond this simple example, there are many options. Let's look at some of them:","title":"B2BUA"},{"location":"developer-guide/sip-dialogs/#copying-headers-from-the-a-leg-onto-the-b-leg","text":"It's quite common for us to want to include on the B leg INVITE some of the headers that we received on the A leg; vice-versa, we may want to include on the A leg response some of the headers that we received on the B leg response. This can be achieved with the opts.proxyRequestHeaders and the opts.proxyResponseHeaders properties in the optional opts parameter. If provided, these should include an array of header names that should be copied from one to the other. The example below illustrates a B2BUA app that wants to pass authentication headers between endpoints srf.invite((req, res) = { srf.createB2BUA(req, res, 'sip:1234@10.10.100.1' { localSdpB: req.body, proxyRequestHeaders: ['Proxy-Authorization', 'Authorization'], proxyResponseHeaders: ['WWW-Authenticate', 'Proxy-Authentication'] }) .then({uas, uac} = { console.log('call successfully connected'); // when one side hangs up, we hang up the other uas.on('destroy', () = uac.destroy()); uac.on('destroy', () = uas.destroy()); }) .catch((err) = console.log(`call failed to connect: ${err}`)); });","title":"Copying headers from the A leg onto the B leg"},{"location":"developer-guide/sip-dialogs/#obtaining-the-uac-dialog-as-soon-as-possible","text":"When the Srf#createB2BUA completes successfully, it provides us the two dialog that have been established. However, in rare cases it may be desirable to receive the UAC dialog as soon as it is established -- that is, as soon as we have received a 200 OK from the B party, before we have sent the 200 OK back to the A party, and before the Srf#createB2BUA](/docs/api#Srf+createB2BUA) method has resolved the Promise that it returns. For this need, similar to Srf#createUAC , there is an optional callback object that contains a callback named cbFinalizedUac that, if provided, is invoked with the UAC dialog as soon as it is created. (Note: the cbProvisional and cbRequest callbacks are also available). srf.invite((req, res) = { srf.createB2BUA(req, res, 'sip:1234@10.10.100.1', { localSdpB: req.body }, { cbFinalizedUac: (uac) = { console.log(`successfully connected to B party at ${uac.remote.contact}`); } }) .then({uas, uac} = { console.log('call successfully connected'); // when one side hangs up, we hang up the other uas.on('destroy', () = uac.destroy()); uac.on('destroy', () = uas.destroy()); }) .catch((err) = console.log(`call failed to connect: ${err}`)); });","title":"Obtaining the UAC dialog as soon as possible"},{"location":"developer-guide/sip-dialogs/#modifying-sdp-offered-to-a-leg-in-sip-response","text":"By default, Srf#createUAC will respond with a 200 OK to the A leg INVITE with the sdp that it received from the B party in the 200 OK on the B leg. In other words, it simply proxies the session description protocol offer from B back to A. Sometimes, however, it is desirable to transform or modify the SDP received on the B leg before sending it back on the A leg. For this purpose, the opts.localSdpA parameter is available. This parameter can either be a string, containing the sdp to offer in the 200 OK back to the A leg, or it can be a function returning a Promise that resolves to the sdp to return in the 200 OK to the A leg. The function has the signature (sdpB, res) , where sdpB is the session description offer we received in the 200 OK from the B party, and res is the response object we received on the B leg. Rather than include an example here, please refer to the source code for the drachtio-b2b-media-proxy application, which is a simple B2BUA that uses rtpengine to proxy the media. This is a great example of when you would want to transform the SDP from B before returning the final session description offer to A.","title":"Modifying SDP offered to A leg in SIP response"},{"location":"developer-guide/sip-dialogs/#choosing-not-to-propagate-failure-from-b-leg","text":"By default, if we get a final SIP non-success from the B party it will be propagated back to the A party. There are times where we would prefer not to do so; for instance, if having failed to connect the A party to one endpoint or phone number, we would now wish to try another. Setting opts.passFailure to value of false enables this behavior. srf.invite((req, res) = { srf.createB2BUA(req, res, 'sip:1234@10.10.100.1', {localSdpB: req.body, passFailure: false}) .then({uas, uac} = { console.log('call connected to primary destination'); }) .catch((err) = { // try backup if we got a sip non-success response and the caller did not hang up if (err.status !== 487) { console.log(`failed connecting to primary, will try backup: ${err}`); srf.createB2BUA(req, res, 'sip:1234@10.10.100.2', { localSdpB: req.body} }) .then({uas, uac} = { console.log('call connected to backup destination'); }) catch((err) = { console.log(`failed connecting to backup uri: ${err}`); }); } }); }); Note that we had to check that the reason for the failure connecting our first attempt was not a 487 Request Cancelled, because this is the error we receive when the caller (A party) hung up before we connected the B party. In that case, we no longer would want to attempt a backup destination. This also answers a related question you may have had: what happens when the A part hangs up before connected, and does our app need to do anything specifically to cancel the B leg when the A leg cancels? The answer to the latter is no, the drachtio framework will automatically cancel the B leg if the A leg is canceled.","title":"Choosing not to propagate failure from B leg"},{"location":"developer-guide/sip-dialogs/#subscribe-dialogs","text":"SUBSCRIBE requests also establish SIP Dialogs, as per RFC 3265 . A UAC (the subscriber ) sends a SUBSCRIBE request with an Event header indicating the event that is being subscribed to, and the UAS (the notifier ) responds with a 202 Accepted response. The UAS should then immediately send a NOTIFY to the UAC of the current state of the requested resource. To terminate a SUBSCRIBE dialog, the UAS sends a NOTIFY request with Subscription-State: terminated; while a UAC would send another SUBSCRIBE with an Expires: 0. The dialog produced by the Srf#createUAS method will be a SUBSCRIBE dialog if the request was a SUBSCRIBE. While the Srf#createUAS method call will send a 202 Accepted, it does not send the initial NOTIFY request that should follow -- the application must do that, since the content can only be determined by the application itself. srf.subscribe((req, res) = { srf.createUAS(req, res, { { headers: {'Expires': req.get('Expires') } }) .then((dialog) = { dialog.on('destroy', () = console.log('remote party terminated dialog')); // send initial NOTIFY let myContent = 'some content reflecting current resource state..'; return dialog.request({ method: 'NOTIFY', headers: { 'Subscription-State': 'active', 'Event': req.get('Event'), 'Content-Type': 'application/pidf+xml' // or whatever }, body: myContent }); }); }); Pro tip: If you need to query a dialog to see whether it is an INVITE or a SUBSCRIBE dialog, you can use the dialogType (read-only) property of the Dialog object to determine that. The Srf#createUAC method can also be used to generate a SUBSCRIBE dialog as a UAC/subscriber. To do this, specify opts.method should be set to 'SUBSCRIBE'. srf.createUac('sip:resource@example.com', { method: 'SUBSCRIBE', headers: { 'From': ' sip:user@locahost ', 'Event': 'presence', 'Expires': 3600 } }) .then((dialog) = { dialog.on('destroy', () = console.log('remote party ended dialog')); dialog.on('notify', (req, res) = { res.send(200); console.log(`received NOTIFY for event ${req.get('Event')}`); if (req.body) { console.log(`received content of type ${req.get('Content-Type')}: ${req.body}`); } }); }); Note in the example above the use of 'localhost' as the host part of the uri of the From header. As mentioned earlier, this will cause the drachtio server to replace this with the appropriate IP address of the server.","title":"Subscribe Dialogs"},{"location":"developer-guide/sip-messages/","text":"SIP Messages In the examples above, we've seen the callback signature (req, res) through which we are passed objects representing a SIP request and an associated response. These objects are event emitters and have some useful properties and methods attached. Since we will be interacting with these objects a lot when writing applications, let's review them now. Properties, methods and events The following properties are available on both req and res objects: type : 'request' or 'response' body : the SIP message body, if any payload : an array of content, useful mainly if the message included multipart content. Each object in the payload array has a type and content property, containing the Content-Type header and the associated content, respectively source : 'network' or 'application'; the sender of the message source_address : the IP address of the sender source_port : the source port of the sender protocol : the transport protocol being used (e.g., 'udp', 'tcp') stackTime : the time the message was sent or received by the drachtio server sip stack calledNumber : the phone number (if any) parsed from the user part of the request uri callingNumber : the phone number (if any) of the calling party, parsed from the P-Asserted-Identity header if it exists, otherwise from the From header. raw : a string containing the full, unparsed SIP message The following methods are available on both req and res objects as well: has(name) : returns true if the message includes the specified header get(name) : returns the value of a specified SIP header set(name, value) : sets the value of a specified SIP header getParsedHeader(name) : returns an object that represents the specified SIP header parsed into components Request-specific properties, methods and events The req object additionally has the following properties: method : the SIP method of the request the following methods: isNewInvite() : returns true if the request is a new INVITE (vs a re-INVITE, or a non-INVITE request) cancel(callback) : cancels an INVITE request that was sent by the application proxy(opts, callback) : proxies an incoming request. While this method is available, the preferred usage is to call srf.proxyRequest() instead. and emits the following events: cancel : this event is emitted for an incoming INVITE request, when a CANCEL for that INVITE is subsequently received from the sender. response : when an application sends a SIP request, an application can listen for the 'response' event to obtain the matching SIP response that is received. Response-specific properties, methods and events The res object additionally has the following properties: status : the SIP response status, as an integer (alias: statusCode ) reason : the SIP reason (e.g. 'Busy Here') finalResponseSent : true if the response message has been sent (alias: headersSent ) and the following methods: send(status, reason, opts, callback) : we have already seen this method used to send a response. Only the status parameter is required. The callback, if provided, will be invoked with the signature (err, msg) where the msg parameter will contain a representation of the SIP response message sent out over the wire. Usage patterns In the few sample code snippets we've looked at so far, we have been receiving SIP requests and then sending SIP responses in return. However, we can also do the reverse -- send out a SIP request and receive a response back. In either case, we are dealing with the request and response objects described above, but different methods and events may apply. Below some of the common patterns are covered. Receiving a request and sending a response srf.options((req, res) = { res.send(200); }); Sending a response with headers srf.options((req, res) = { res.send(200, { headers: { 'Subject': 'All\\'s well here' } }); }); Sending a response with callback to get the msg actually sent srf.options((req, res) = { res.send(200, { headers: { 'Subject': 'All\\'s well here' } }, (err, msg) = { const to = msg.getParsedHeader('To'); console.log(`drachtio server added tag on To header: ${to.params.tag}`); }); }); Sending a request, and then receiving the response srf.request('sip:1234@example.com', { method: 'OPTIONS' }, (err, req) = { // req is the SIP request that went out over the wire req.on('response', (res) = { console.log(`received ${res.status} response to our OPTIONS request`); }); }); Sending a request with headers and body const dtmf = `Signal=5 Duration=160`; srf.request('sip:1234@example.com', { method: 'INFO', headers: { 'Content-Type': 'application/dtmf-relay' }, body: dtmf }); Handling the cancel of an INVITE srf.invite((req, res) = { let canceled = false; req.on('cancel', () = canceled = true); doLengthyDatabaseLookup() .then((results) = { // was the call canceled while // we were doing database lookup? if (canceled) return; ..go on to process the call }) })","title":"sip messages"},{"location":"developer-guide/sip-messages/#sip-messages","text":"In the examples above, we've seen the callback signature (req, res) through which we are passed objects representing a SIP request and an associated response. These objects are event emitters and have some useful properties and methods attached. Since we will be interacting with these objects a lot when writing applications, let's review them now.","title":"SIP Messages"},{"location":"developer-guide/sip-messages/#properties-methods-and-events","text":"The following properties are available on both req and res objects: type : 'request' or 'response' body : the SIP message body, if any payload : an array of content, useful mainly if the message included multipart content. Each object in the payload array has a type and content property, containing the Content-Type header and the associated content, respectively source : 'network' or 'application'; the sender of the message source_address : the IP address of the sender source_port : the source port of the sender protocol : the transport protocol being used (e.g., 'udp', 'tcp') stackTime : the time the message was sent or received by the drachtio server sip stack calledNumber : the phone number (if any) parsed from the user part of the request uri callingNumber : the phone number (if any) of the calling party, parsed from the P-Asserted-Identity header if it exists, otherwise from the From header. raw : a string containing the full, unparsed SIP message The following methods are available on both req and res objects as well: has(name) : returns true if the message includes the specified header get(name) : returns the value of a specified SIP header set(name, value) : sets the value of a specified SIP header getParsedHeader(name) : returns an object that represents the specified SIP header parsed into components","title":"Properties, methods and events"},{"location":"developer-guide/sip-messages/#request-specific-properties-methods-and-events","text":"The req object additionally has the following properties: method : the SIP method of the request the following methods: isNewInvite() : returns true if the request is a new INVITE (vs a re-INVITE, or a non-INVITE request) cancel(callback) : cancels an INVITE request that was sent by the application proxy(opts, callback) : proxies an incoming request. While this method is available, the preferred usage is to call srf.proxyRequest() instead. and emits the following events: cancel : this event is emitted for an incoming INVITE request, when a CANCEL for that INVITE is subsequently received from the sender. response : when an application sends a SIP request, an application can listen for the 'response' event to obtain the matching SIP response that is received.","title":"Request-specific properties, methods and events"},{"location":"developer-guide/sip-messages/#response-specific-properties-methods-and-events","text":"The res object additionally has the following properties: status : the SIP response status, as an integer (alias: statusCode ) reason : the SIP reason (e.g. 'Busy Here') finalResponseSent : true if the response message has been sent (alias: headersSent ) and the following methods: send(status, reason, opts, callback) : we have already seen this method used to send a response. Only the status parameter is required. The callback, if provided, will be invoked with the signature (err, msg) where the msg parameter will contain a representation of the SIP response message sent out over the wire.","title":"Response-specific properties, methods and events"},{"location":"developer-guide/sip-messages/#usage-patterns","text":"In the few sample code snippets we've looked at so far, we have been receiving SIP requests and then sending SIP responses in return. However, we can also do the reverse -- send out a SIP request and receive a response back. In either case, we are dealing with the request and response objects described above, but different methods and events may apply. Below some of the common patterns are covered.","title":"Usage patterns"},{"location":"developer-guide/sip-messages/#receiving-a-request-and-sending-a-response","text":"srf.options((req, res) = { res.send(200); });","title":"Receiving a request and sending a response"},{"location":"developer-guide/sip-messages/#sending-a-response-with-headers","text":"srf.options((req, res) = { res.send(200, { headers: { 'Subject': 'All\\'s well here' } }); });","title":"Sending a response with headers"},{"location":"developer-guide/sip-messages/#sending-a-response-with-callback-to-get-the-msg-actually-sent","text":"srf.options((req, res) = { res.send(200, { headers: { 'Subject': 'All\\'s well here' } }, (err, msg) = { const to = msg.getParsedHeader('To'); console.log(`drachtio server added tag on To header: ${to.params.tag}`); }); });","title":"Sending a response with callback to get the msg actually sent"},{"location":"developer-guide/sip-messages/#sending-a-request-and-then-receiving-the-response","text":"srf.request('sip:1234@example.com', { method: 'OPTIONS' }, (err, req) = { // req is the SIP request that went out over the wire req.on('response', (res) = { console.log(`received ${res.status} response to our OPTIONS request`); }); });","title":"Sending a request, and then receiving the response"},{"location":"developer-guide/sip-messages/#sending-a-request-with-headers-and-body","text":"const dtmf = `Signal=5 Duration=160`; srf.request('sip:1234@example.com', { method: 'INFO', headers: { 'Content-Type': 'application/dtmf-relay' }, body: dtmf });","title":"Sending a request with headers and body"},{"location":"developer-guide/sip-messages/#handling-the-cancel-of-an-invite","text":"srf.invite((req, res) = { let canceled = false; req.on('cancel', () = canceled = true); doLengthyDatabaseLookup() .then((results) = { // was the call canceled while // we were doing database lookup? if (canceled) return; ..go on to process the call }) })","title":"Handling the cancel of an INVITE"},{"location":"developer-guide/sip-proxy/","text":"SIP Proxy Building a SIP proxy with drachtio is pretty darn simple. srf.invite((req, res) = { srf.proxyRequest(req, 'sip.example1.com') .then((results) = console.log(JSON.stringify(result)) ); }); In the example above, we receive an INVITE and then proxy it onwards to the server at 'sip.example1.com'. Note: as with other methods, a callback variant is also available. Srf#proxyRequest returns a Promise that resolves when the proxy transaction is complete -- i.e. final responses and ACKs have been transmitted, and the call is either connected or has resulted in a final non-success response. The results value that the Promise resolves provides a complete description of the results. There are a bunch of options that we can utilize when proxying a call, but before we take a look at those let's consider the two fundamentally different proxy scenarios that we might encounter: 1. The incoming INVITE has a Request-URI of the dractio server, and we want to proxy it on towards a next sip uri that we supply in the calll to Srf#proxyRequest . An example of this use case occurs when we have a drachtio server acting as a load balancer in front of an array of application or media servers. 2. The incoming INVITE has a Request-URI of a remote endpoint, and we want to proxy it on towards that endpoint. An example of this use case occurs when we have a drachtio server acting as an outbound SIP proxy. How we handle these two scenarios is governed by whether we supply a sip uri in the call to Srf#proxyRequest . In the first example above, we supplied a sip uri in the method call and as a result the drachtio server will do the following: * If the incoming INVITE had a Request-URI that matches a local address that the drachtio server is listening on, then it will replace the Request-URI in the outbound INVITE to that specified in the method call and will forward the INVITE to that address. * Otherwise, the outbound INVITE will leave the Request-URI unchanged while forwarding the INVITE to the sip uri specified in the method call. An implication of this is that we can call Srf#proxyRequest without specifying a sip uri at all; in this case, drachtio acts as an outbound proxy and forwards the INVITE towards the Request-URI of the incoming INVITE. SIP proxy acting as a load balancer srf.invite((req, res) = { srf.proxyRequest(req, ['sip.example1.com','sip2.example1.com]') .then((results) = console.log(JSON.stringify(result)) ); }); The above example illustrates that we can provide either a string or an Array of strings as the sip uri to proxy an INVITE to. In the latter case, if the INVITE fails on the first sip server it will then be attempted on the second, and so on until a successful response is received or the list is exhausted. SIP outbound proxy srf.invite((req, res) = { srf.proxyRequest(req) .then((results) = console.log(JSON.stringify(result)) ); }); In the above example there is no need to supply a sip uri if the drachtio server is acting as a simple outbound proxy. SIP Proxy options srf.invite((req, res) = { srf.proxyRequest(req, ['sip.example1.com','sip2.example1.com]', { recordRoute: true, followRedirects: true, forking: true, provisionalTimeout: '2s', finalTimeout: '18s' }) .then((results) = console.log(JSON.stringify(result)) ); }); See Srf#proxyRequest for a detailed explanation of these options.","title":"sip proxy"},{"location":"developer-guide/sip-proxy/#sip-proxy","text":"Building a SIP proxy with drachtio is pretty darn simple. srf.invite((req, res) = { srf.proxyRequest(req, 'sip.example1.com') .then((results) = console.log(JSON.stringify(result)) ); }); In the example above, we receive an INVITE and then proxy it onwards to the server at 'sip.example1.com'. Note: as with other methods, a callback variant is also available. Srf#proxyRequest returns a Promise that resolves when the proxy transaction is complete -- i.e. final responses and ACKs have been transmitted, and the call is either connected or has resulted in a final non-success response. The results value that the Promise resolves provides a complete description of the results. There are a bunch of options that we can utilize when proxying a call, but before we take a look at those let's consider the two fundamentally different proxy scenarios that we might encounter: 1. The incoming INVITE has a Request-URI of the dractio server, and we want to proxy it on towards a next sip uri that we supply in the calll to Srf#proxyRequest . An example of this use case occurs when we have a drachtio server acting as a load balancer in front of an array of application or media servers. 2. The incoming INVITE has a Request-URI of a remote endpoint, and we want to proxy it on towards that endpoint. An example of this use case occurs when we have a drachtio server acting as an outbound SIP proxy. How we handle these two scenarios is governed by whether we supply a sip uri in the call to Srf#proxyRequest . In the first example above, we supplied a sip uri in the method call and as a result the drachtio server will do the following: * If the incoming INVITE had a Request-URI that matches a local address that the drachtio server is listening on, then it will replace the Request-URI in the outbound INVITE to that specified in the method call and will forward the INVITE to that address. * Otherwise, the outbound INVITE will leave the Request-URI unchanged while forwarding the INVITE to the sip uri specified in the method call. An implication of this is that we can call Srf#proxyRequest without specifying a sip uri at all; in this case, drachtio acts as an outbound proxy and forwards the INVITE towards the Request-URI of the incoming INVITE.","title":"SIP Proxy"},{"location":"developer-guide/sip-proxy/#sip-proxy-acting-as-a-load-balancer","text":"srf.invite((req, res) = { srf.proxyRequest(req, ['sip.example1.com','sip2.example1.com]') .then((results) = console.log(JSON.stringify(result)) ); }); The above example illustrates that we can provide either a string or an Array of strings as the sip uri to proxy an INVITE to. In the latter case, if the INVITE fails on the first sip server it will then be attempted on the second, and so on until a successful response is received or the list is exhausted.","title":"SIP proxy acting as a load balancer"},{"location":"developer-guide/sip-proxy/#sip-outbound-proxy","text":"srf.invite((req, res) = { srf.proxyRequest(req) .then((results) = console.log(JSON.stringify(result)) ); }); In the above example there is no need to supply a sip uri if the drachtio server is acting as a simple outbound proxy.","title":"SIP outbound proxy"},{"location":"developer-guide/sip-proxy/#sip-proxy-options","text":"srf.invite((req, res) = { srf.proxyRequest(req, ['sip.example1.com','sip2.example1.com]', { recordRoute: true, followRedirects: true, forking: true, provisionalTimeout: '2s', finalTimeout: '18s' }) .then((results) = console.log(JSON.stringify(result)) ); }); See Srf#proxyRequest for a detailed explanation of these options.","title":"SIP Proxy options"},{"location":"drachtio-server/configuring/","text":"Configuring The drachtio process can either be configured via command-line parameters, environment variables, a configuration file -- or a combination of all three. The order of precedence of configuration settings is as follows: * command-line parameters, if provided, always take precedence * otherwise environment variables, if provided, take precedence * otherwise configuration file settings are used. By default, the server will look for a configuration file at /etc/drachtio.conf.xml . This can be changed by passing the configuration file path as a command line argument -f ; e.g., drachtio -f /tmp/drachtio.conf.xml As the name suggests, the configuration file is in XML format. The structure of the file is described below, and a heavily commented version of the file can be found here that provides additional detail to the summary provided below. drachtio.conf.xml A drachtio configuration file has the following high-level structure: drachtio admin/ request-handlers/ sip/ cdrs/ monitoring/ logging/ /drachtio Each section is described below, along with the command line parameters and environemnt variables that can be used to configure the same settings. admin section The admin section is required and specifies how the drachtio server will listen for incoming connections from drachtio applications. The information includes the tcp port to listen on, the address(es) to listen on (0.0.0.0 means all available interfaces), the shared secret that is used for authentication, and whether tcp keep alives will be sent on these connections. Note that as of release 0.8.0, there is also an option to use tls encryption on connections. For inbound connections, this is specified by providing a 'tls-port' option. The server can be configured to handle either, or both, tcp and tls connections. admin port= 9022 tls-port= 9023 secret= cymru tcp-keepalive-interval= 30 0.0.0.0 /admin or, using command-line parameters: drachtio --port 9022 --tls-port 9023 --secret cymru --tcp-keepalive-interval 30 or, using environment variables DRACHTIO_ADMIN_TCP_PORT=9022 \\ DRACHTIO_ADMIN_TLS_PORT=9023 \\ DRACHTIO_TCP_KEEPALIVE_INTERVAL=30 \\ DRACHTIO_SECRET=cymru drachtio Note that by default, tcp keepalives are enabled with an interval of 45 seconds. The value can be changed, as above, or disabled by setting it to a value of zero. request-handlers section The request-handlers section is optional and configures the drachtio process to establish outbound connections to drachtio servers for some or all SIP methods instead of inbound connections . The request-handlers element can have zero or more child request-handler elements. Each request-handlers defines a specific SIP method (or * to wildcard all methods) and an http(s) web callback to invoke when a new request of the specified method type arrives. It is the responsibility of the user-supplied web callback to return information in an HTTP 200 OK response indicating how to route the call. request-handlers request-handler sip-method= INVITE http-method= GET verify-peer= false https://38.187.89.96:8080 /request-handler /request-handlers With the configuration above in place, when the drachtio server receives a new incoming INVITE request, it will send an HTTP GET to the URL above, with HTTP query arguments * method : the SIP method of the request * domain : the SIP domain in the Request-URI * protocol : the transport protocol used (e.g. 'udp', 'tcp', 'wss', etc) * source_address : the IP address of the sender * fromUser : the user part of the uri in the From header * toUser : the user part of the uri in the To header * uriUser : the user part of the uri in the Request-URI * contentType : the Content-Type header in the request, if any * uri : the full Request-URI Note: either HTTP or HTTPS URIs are supported. If using self-signed certificates with HTTPS, set verify-peer to false, as above. Note: setting http-method=\"POST\" will cause an HTTP POST top be sent to the user-supplied web callback. All of the information supplied below will be provided (e.g. query args) but additionally the body of the request will have a full copy of the incoming SIP request message. This is useful in more complex routing scenarios which may, for instance, depend on examining specific values in the SIP headers of the incoming message. An example HTTP URL that gets sent out looks like this: http://38.187.89.96:8080/?method=INVITE domain=server-01.drachtio.org protocol=udp source_address=10.132.0.29 fromUser=%2b15083084809 toUser=calltest uriUser=r-ee78299f-2f85-4d92-97ab-24f1d11e2b69 contentType=application%2fsdp uri=sip%3ar-ee78299f-2f85-4d92-97ab-24f1d11e2b69%server-01.drachtio.org%3bdst%3d%2b15083084809%2540139.59.165.83%3a5060 dst=%2b15083084809%2540139.59.165.83%3a5060 ``` Based on the information above provided in the HTTP request, the user-supplied callback is responsible for indicating one of the following actions in a JSON body of the HTTP 200 OK response: * return a non-success response to the request * proxy the request * redirect the request (valid for INVITE only) * route the request to a specified drachtio application The first three actions completely disposition the incoming SIP request -- i.e. no further interaction with a drachtio application occurs. The final action (route to an application) causes the drachtio server to establish an outbound tcp connection to a drachtio application listening on a specified port, which then receives and processes the request normally (e.g. in a `srf.invite((req, res)))` or equivalent). Note that as of release 0.8.0, it is possible route to a drachtio application over an outbound connection using tls. This is specified by appending a `transport` attribute to the uri and specifying 'tls', e.g. `uri:myapp.example.com;transport=tls`. Example JSON responses for each of the above action are illustrated below (note: a response should include only one of the JSON payloads below): ```js // this would reject the call with a 503 Max Calls Exceeded response // note: reason is optional { reject : data : { status : 503, reason : Max Calls Exceeded } } // this redirects the call to the address specified. // the Contact header of the response will be populated accordingly { redirect : data : { contacts : [ sip:foo@bar.com ] } } // this proxies the call accordingly { proxy : data : { destination : [ sip:foo@bar.com ], recordRoute: true } } // this causes the request to be delivered to a drachtio app for further processing. // the drachtio app must be listening on the uri provided; i.e an outbound connection. { route : data : { uri : call-recording.default.svc.cluster.local:4000 } } // this causes the request to be delivered to a drachtio app for further processing. // the drachtio app must be using tagged inbound connections. { route : data : { tag : conferencing-app } } Note: the last stanza above applies to using tagged inbound connections. For more details, see here A request handler for all incoming SIP requests can be configured via the command-line as well: drachtio --http-handler http://38.187.89.96:8080 --http-method GET sip section The sip section defines which addresses and ports the SIP stack will listen on, which protocols will be supported, where to find (if necessary) SSL certificates, and other SIP options. contacts The drachtio server can listen on multiple interfaces/addresses for SIP traffic. These are defined in a contacts element that has child contact elements for each SIP endpoint. Examples of possible configuration are shown below. !-- listen on all addresses, default port 5060 for udp and tcp protocols -- sip contacts contact sip:*;transport=udp,tcp /contact /contacts /sip !-- listen on ports 5060 and 5080 -- contacts contact sip:*;transport=udp,tcp /contact contact sip:*:5080;transport=udp,tcp /contact /contacts !-- listen for secure websockets on specific address and port -- contacts contact sip:192.168.100.23:443;transport=wss /contact /contacts Additionally, if the SIP server has been assigned an external address that should be used in the SIP signaling, this should be specified as follows: contacts contact external-ip= 35.195.28.194 sip:10.132.0.22;transport=udp,tcp /contact /contacts This will cause the drachtio server to advertise its address as 35.195.28.194 in Contact and Via headers, even though its local assigned IP address is 10.132.0.22 . Furthermore, if the drachtio server has an assigned DNS name, this should be configured as well so that it can detect when the Request-URI of an incoming SIP request is referring to the local host when the DNS name appears in the host portion. contacts contact dns-names= server01.drachtio.org external-ip= 35.195.28.194 sip:10.132.0.22;transport=udp,tcp /contact /contacts Note: multiple DNS names can be provided in comma-separated format. SIP contacts can be supplied via command line as follows drachtio --contact sip:10.132.0.22;transport=udp --external-ip 35.195.28.194 timers The SIP spec contains definitions for timers governing retransmissions of SIP requests and the like. Generally, there is no need to modify the setting for these timers, but if desired this can be done as follows: timers t1 500 /t1 t2 4000 /t2 t4 5000 /t4 t1x64 32000 /t1x64 /timers Note: values are in milliseconds. The example above actually sets the timers to their defined default values, so if you are using this section you would like be setting them to some other values. You only need to specify those timers that you want to adjust from their default values. tls If you are using either TLS or WSS as a transport, then you must specify where the associated tls certificates are stored on the server. Additionally, when using tls on admin connections from applications, you must specify a dhparam file that contains the Diffie-Hellman (dh) parameters. (This is not required if you are only using TLS to secure SIP connections) tls key-file /etc/letsencrypt/live/yourdomain/privkey.pem /key-file cert-file /etc/letsencrypt/live/yourdomain/cert.pem /cert-file chain-file /etc/letsencrypt/live/yourdomain/chain.pem /chain-file dh-param /var/local/private/dh4096.pem /dh-param /tls or, via command-line drachtio --key-file keyfile --cert-file certfile --chain-file chainfile --dh-param dhparamfile outbound-proxy This causes all outbound requests to be sent through an outbound proxy outbound-proxy sip:10.10.10.1 /outbound-proxy spammers The drachtio server can examine the Contact, To, and From headers for distinctive signatures that indicate the request was sent from a spam source. If a spammer is detected, the message can either be rejected or silently discarded. spammers action= reject action= discard header name= User-Agent value sip-cli /value value sipcli /value value friendly-scanner /value /header header name= To value sipvicious /value /header /spammers capture-server The drachtio server can be configured to send to Homer using the HEP protocol. capture-server port= 9060 hep-version= 3 id= 101 127.0.0.1 /capture-server or, via command line drachtio --homer 127.0.0.1:9060 --homer-id 101 or, via environment variables: DRACHTIO_HOMER_ADDRESS=127.0.0.1 \\ DRACHTIO_HOMER_PORT=9060 \\ DRACHTIO_HOMER_ID=101 drachtio udp-mtu Added in version 0.7.3-rc2 sofia-sip has an annoying feature where it forces an outbound request to go out TCP if the packet size exceeds a specific threshold (usually 1300 bytes). Tis configuration setting allows users to increase this threshold to an arbitrary value. udp-mtu 4096 /udp-mtu or, via command line drachtio --mtu 4096 or, via environment variables DRACHTIO_UDP_MTU=4096 drachtio monitoring section drachtio supports prometheus monitoring by optionally exposing a /metrics endpoint. See here for a list of the metrics provided monitoring prometheus port= 9090 127.0.0.1 /prometheus /monitoring Note: if the address is not provided, the /metrics endpoints will be available on all interfaces (e.g. 0.0.0.0). or, via command line: drachtio --prometheus-scrape-port 9090 # above implies 0.0.0.0:9090, we can be more explicit drachtio --prometheus-scrape-port 10.0.1.5:9090 or, via environment variables DRACHTIO_PROMETHEUS_SCRAPE_PORT=9090 drachtio # or DRACHTIO_PROMETHEUS_SCRAPE_PORT=10.0.1.5:9090 drachtio logging section The logging section defines where drachtio server will send logging information, including sip traces. Logging destinations include the console, a named log file on the server, or syslog. Any or all of them may be used at one time. console To log output to the console simply include a console\\ child element. syslog To send log output to a syslog server via UDP, specify the following: syslog address 127.0.0.1 /address port 514 /port facility local6 /facility /syslog log file To send log output to a log file on the server, specify the following: file name /var/log/drachtio/drachtio.log /name archive /var/log/drachtio/archive /archive size 50 /size maxSize 100 /maxSize minSize 2000 /minSize auto-flush true /auto-flush /file The options are as follows: * name : path to the log file * archive : path a directory where older log files were be archived * size : the size (in MB) at which the log file is truncated * maxSize : the max size (in MB) of archived files to keep * minSize : the minimum freespace (in MB) on the filesytem to maintain when archiving * auto-flush : if true, log information is written immediately to disk; otherwise log file is buffered and written intermittently (slightly better performance) loglevel The overall system log level: 'notice', 'warning', 'error', 'info, or 'debug'. loglevel info /loglevel Note: 'info' is the recommended log level for production systems. At this log level you will get sip traces, which are useful for debugging. sofia-loglevel The drachtio server uses the sofia library internally. The log level for this library can be set from 0 (minimal) to 9 (extensive). sofia-loglevel 3 /sofia-loglevel command-line arguments The drachtio executable can accept command-line arguments that specify some configuration parameters. If provided, the command-line configuration parameters take preference over those specified in the configuration file. The supported drachtio command-line arguments are: * --daemon detach from the console and run as a daemon process. Note: when running as a systemd service, this parameter is not necessary. * --noconfig ignore any logging configuration in the configuration file * --file|-f filename read configuration from specified file rather that /etc/drachtio.conf.xml * --user|-u user run as the named user rather than root * --port|-p port listen for tcp admin connections on the named port * --tls-port listen for tls admin connections on the named port. Added in version 0.8.0-rc1 . * --contact|-c specifies a listening address/port/protocol. Multiple instances of this parameter may be provided * --external-ip ip-address specifies an external address that the drachtio server should advertise in the SIP signaling. This parameter applies to the --contact parameter that it follows in the command line. * dns-name name a dns name that refer to the local server. This parameter applies to the --contact parameter that it follows in the command line. * http-handler url an HTTP URL of a web callback that will be invoked for all new incoming requests. Setting this parameter turns on outbound connections for all SIP request types. * http-method either 'GET' or 'PUT' * --loglevel level the overall log level to set * --sofia-loglevel level the log level of the sofia library * --stdout write log output to console * --homer ip-address:port ip address of homer capture server to send to. HEP3 and udp transport will be used * --homer-id id id to use to represent this server when sending messages to homer * --version print the drachtio server version to console and exit. * --mtu specifies a message size, in bytes, for requests such that when outgoing requests exceed this threshold use of tcp is forced (this overrides the default sofia stack setting for the same). Added in version 0.7.3-rc2 . * --dh-param dhparam file used for inbound tls admin connections. Added in version 0.8.0-rc1 .","title":"configuring"},{"location":"drachtio-server/configuring/#configuring","text":"The drachtio process can either be configured via command-line parameters, environment variables, a configuration file -- or a combination of all three. The order of precedence of configuration settings is as follows: * command-line parameters, if provided, always take precedence * otherwise environment variables, if provided, take precedence * otherwise configuration file settings are used. By default, the server will look for a configuration file at /etc/drachtio.conf.xml . This can be changed by passing the configuration file path as a command line argument -f ; e.g., drachtio -f /tmp/drachtio.conf.xml As the name suggests, the configuration file is in XML format. The structure of the file is described below, and a heavily commented version of the file can be found here that provides additional detail to the summary provided below.","title":"Configuring"},{"location":"drachtio-server/configuring/#drachtioconfxml","text":"A drachtio configuration file has the following high-level structure: drachtio admin/ request-handlers/ sip/ cdrs/ monitoring/ logging/ /drachtio Each section is described below, along with the command line parameters and environemnt variables that can be used to configure the same settings.","title":"drachtio.conf.xml"},{"location":"drachtio-server/configuring/#admin-section","text":"The admin section is required and specifies how the drachtio server will listen for incoming connections from drachtio applications. The information includes the tcp port to listen on, the address(es) to listen on (0.0.0.0 means all available interfaces), the shared secret that is used for authentication, and whether tcp keep alives will be sent on these connections. Note that as of release 0.8.0, there is also an option to use tls encryption on connections. For inbound connections, this is specified by providing a 'tls-port' option. The server can be configured to handle either, or both, tcp and tls connections. admin port= 9022 tls-port= 9023 secret= cymru tcp-keepalive-interval= 30 0.0.0.0 /admin or, using command-line parameters: drachtio --port 9022 --tls-port 9023 --secret cymru --tcp-keepalive-interval 30 or, using environment variables DRACHTIO_ADMIN_TCP_PORT=9022 \\ DRACHTIO_ADMIN_TLS_PORT=9023 \\ DRACHTIO_TCP_KEEPALIVE_INTERVAL=30 \\ DRACHTIO_SECRET=cymru drachtio Note that by default, tcp keepalives are enabled with an interval of 45 seconds. The value can be changed, as above, or disabled by setting it to a value of zero.","title":"admin section"},{"location":"drachtio-server/configuring/#request-handlers-section","text":"The request-handlers section is optional and configures the drachtio process to establish outbound connections to drachtio servers for some or all SIP methods instead of inbound connections . The request-handlers element can have zero or more child request-handler elements. Each request-handlers defines a specific SIP method (or * to wildcard all methods) and an http(s) web callback to invoke when a new request of the specified method type arrives. It is the responsibility of the user-supplied web callback to return information in an HTTP 200 OK response indicating how to route the call. request-handlers request-handler sip-method= INVITE http-method= GET verify-peer= false https://38.187.89.96:8080 /request-handler /request-handlers With the configuration above in place, when the drachtio server receives a new incoming INVITE request, it will send an HTTP GET to the URL above, with HTTP query arguments * method : the SIP method of the request * domain : the SIP domain in the Request-URI * protocol : the transport protocol used (e.g. 'udp', 'tcp', 'wss', etc) * source_address : the IP address of the sender * fromUser : the user part of the uri in the From header * toUser : the user part of the uri in the To header * uriUser : the user part of the uri in the Request-URI * contentType : the Content-Type header in the request, if any * uri : the full Request-URI Note: either HTTP or HTTPS URIs are supported. If using self-signed certificates with HTTPS, set verify-peer to false, as above. Note: setting http-method=\"POST\" will cause an HTTP POST top be sent to the user-supplied web callback. All of the information supplied below will be provided (e.g. query args) but additionally the body of the request will have a full copy of the incoming SIP request message. This is useful in more complex routing scenarios which may, for instance, depend on examining specific values in the SIP headers of the incoming message. An example HTTP URL that gets sent out looks like this: http://38.187.89.96:8080/?method=INVITE domain=server-01.drachtio.org protocol=udp source_address=10.132.0.29 fromUser=%2b15083084809 toUser=calltest uriUser=r-ee78299f-2f85-4d92-97ab-24f1d11e2b69 contentType=application%2fsdp uri=sip%3ar-ee78299f-2f85-4d92-97ab-24f1d11e2b69%server-01.drachtio.org%3bdst%3d%2b15083084809%2540139.59.165.83%3a5060 dst=%2b15083084809%2540139.59.165.83%3a5060 ``` Based on the information above provided in the HTTP request, the user-supplied callback is responsible for indicating one of the following actions in a JSON body of the HTTP 200 OK response: * return a non-success response to the request * proxy the request * redirect the request (valid for INVITE only) * route the request to a specified drachtio application The first three actions completely disposition the incoming SIP request -- i.e. no further interaction with a drachtio application occurs. The final action (route to an application) causes the drachtio server to establish an outbound tcp connection to a drachtio application listening on a specified port, which then receives and processes the request normally (e.g. in a `srf.invite((req, res)))` or equivalent). Note that as of release 0.8.0, it is possible route to a drachtio application over an outbound connection using tls. This is specified by appending a `transport` attribute to the uri and specifying 'tls', e.g. `uri:myapp.example.com;transport=tls`. Example JSON responses for each of the above action are illustrated below (note: a response should include only one of the JSON payloads below): ```js // this would reject the call with a 503 Max Calls Exceeded response // note: reason is optional { reject : data : { status : 503, reason : Max Calls Exceeded } } // this redirects the call to the address specified. // the Contact header of the response will be populated accordingly { redirect : data : { contacts : [ sip:foo@bar.com ] } } // this proxies the call accordingly { proxy : data : { destination : [ sip:foo@bar.com ], recordRoute: true } } // this causes the request to be delivered to a drachtio app for further processing. // the drachtio app must be listening on the uri provided; i.e an outbound connection. { route : data : { uri : call-recording.default.svc.cluster.local:4000 } } // this causes the request to be delivered to a drachtio app for further processing. // the drachtio app must be using tagged inbound connections. { route : data : { tag : conferencing-app } } Note: the last stanza above applies to using tagged inbound connections. For more details, see here A request handler for all incoming SIP requests can be configured via the command-line as well: drachtio --http-handler http://38.187.89.96:8080 --http-method GET","title":"request-handlers section"},{"location":"drachtio-server/configuring/#sip-section","text":"The sip section defines which addresses and ports the SIP stack will listen on, which protocols will be supported, where to find (if necessary) SSL certificates, and other SIP options.","title":"sip section"},{"location":"drachtio-server/configuring/#contacts","text":"The drachtio server can listen on multiple interfaces/addresses for SIP traffic. These are defined in a contacts element that has child contact elements for each SIP endpoint. Examples of possible configuration are shown below. !-- listen on all addresses, default port 5060 for udp and tcp protocols -- sip contacts contact sip:*;transport=udp,tcp /contact /contacts /sip !-- listen on ports 5060 and 5080 -- contacts contact sip:*;transport=udp,tcp /contact contact sip:*:5080;transport=udp,tcp /contact /contacts !-- listen for secure websockets on specific address and port -- contacts contact sip:192.168.100.23:443;transport=wss /contact /contacts Additionally, if the SIP server has been assigned an external address that should be used in the SIP signaling, this should be specified as follows: contacts contact external-ip= 35.195.28.194 sip:10.132.0.22;transport=udp,tcp /contact /contacts This will cause the drachtio server to advertise its address as 35.195.28.194 in Contact and Via headers, even though its local assigned IP address is 10.132.0.22 . Furthermore, if the drachtio server has an assigned DNS name, this should be configured as well so that it can detect when the Request-URI of an incoming SIP request is referring to the local host when the DNS name appears in the host portion. contacts contact dns-names= server01.drachtio.org external-ip= 35.195.28.194 sip:10.132.0.22;transport=udp,tcp /contact /contacts Note: multiple DNS names can be provided in comma-separated format. SIP contacts can be supplied via command line as follows drachtio --contact sip:10.132.0.22;transport=udp --external-ip 35.195.28.194","title":"contacts"},{"location":"drachtio-server/configuring/#timers","text":"The SIP spec contains definitions for timers governing retransmissions of SIP requests and the like. Generally, there is no need to modify the setting for these timers, but if desired this can be done as follows: timers t1 500 /t1 t2 4000 /t2 t4 5000 /t4 t1x64 32000 /t1x64 /timers Note: values are in milliseconds. The example above actually sets the timers to their defined default values, so if you are using this section you would like be setting them to some other values. You only need to specify those timers that you want to adjust from their default values.","title":"timers"},{"location":"drachtio-server/configuring/#tls","text":"If you are using either TLS or WSS as a transport, then you must specify where the associated tls certificates are stored on the server. Additionally, when using tls on admin connections from applications, you must specify a dhparam file that contains the Diffie-Hellman (dh) parameters. (This is not required if you are only using TLS to secure SIP connections) tls key-file /etc/letsencrypt/live/yourdomain/privkey.pem /key-file cert-file /etc/letsencrypt/live/yourdomain/cert.pem /cert-file chain-file /etc/letsencrypt/live/yourdomain/chain.pem /chain-file dh-param /var/local/private/dh4096.pem /dh-param /tls or, via command-line drachtio --key-file keyfile --cert-file certfile --chain-file chainfile --dh-param dhparamfile","title":"tls"},{"location":"drachtio-server/configuring/#outbound-proxy","text":"This causes all outbound requests to be sent through an outbound proxy outbound-proxy sip:10.10.10.1 /outbound-proxy","title":"outbound-proxy"},{"location":"drachtio-server/configuring/#spammers","text":"The drachtio server can examine the Contact, To, and From headers for distinctive signatures that indicate the request was sent from a spam source. If a spammer is detected, the message can either be rejected or silently discarded. spammers action= reject action= discard header name= User-Agent value sip-cli /value value sipcli /value value friendly-scanner /value /header header name= To value sipvicious /value /header /spammers","title":"spammers"},{"location":"drachtio-server/configuring/#capture-server","text":"The drachtio server can be configured to send to Homer using the HEP protocol. capture-server port= 9060 hep-version= 3 id= 101 127.0.0.1 /capture-server or, via command line drachtio --homer 127.0.0.1:9060 --homer-id 101 or, via environment variables: DRACHTIO_HOMER_ADDRESS=127.0.0.1 \\ DRACHTIO_HOMER_PORT=9060 \\ DRACHTIO_HOMER_ID=101 drachtio","title":"capture-server"},{"location":"drachtio-server/configuring/#udp-mtu","text":"Added in version 0.7.3-rc2 sofia-sip has an annoying feature where it forces an outbound request to go out TCP if the packet size exceeds a specific threshold (usually 1300 bytes). Tis configuration setting allows users to increase this threshold to an arbitrary value. udp-mtu 4096 /udp-mtu or, via command line drachtio --mtu 4096 or, via environment variables DRACHTIO_UDP_MTU=4096 drachtio","title":"udp-mtu"},{"location":"drachtio-server/configuring/#monitoring-section","text":"drachtio supports prometheus monitoring by optionally exposing a /metrics endpoint. See here for a list of the metrics provided monitoring prometheus port= 9090 127.0.0.1 /prometheus /monitoring Note: if the address is not provided, the /metrics endpoints will be available on all interfaces (e.g. 0.0.0.0). or, via command line: drachtio --prometheus-scrape-port 9090 # above implies 0.0.0.0:9090, we can be more explicit drachtio --prometheus-scrape-port 10.0.1.5:9090 or, via environment variables DRACHTIO_PROMETHEUS_SCRAPE_PORT=9090 drachtio # or DRACHTIO_PROMETHEUS_SCRAPE_PORT=10.0.1.5:9090 drachtio","title":"monitoring section"},{"location":"drachtio-server/configuring/#logging-section","text":"The logging section defines where drachtio server will send logging information, including sip traces. Logging destinations include the console, a named log file on the server, or syslog. Any or all of them may be used at one time.","title":"logging section"},{"location":"drachtio-server/configuring/#console","text":"To log output to the console simply include a console\\ child element.","title":"console"},{"location":"drachtio-server/configuring/#syslog","text":"To send log output to a syslog server via UDP, specify the following: syslog address 127.0.0.1 /address port 514 /port facility local6 /facility /syslog","title":"syslog"},{"location":"drachtio-server/configuring/#log-file","text":"To send log output to a log file on the server, specify the following: file name /var/log/drachtio/drachtio.log /name archive /var/log/drachtio/archive /archive size 50 /size maxSize 100 /maxSize minSize 2000 /minSize auto-flush true /auto-flush /file The options are as follows: * name : path to the log file * archive : path a directory where older log files were be archived * size : the size (in MB) at which the log file is truncated * maxSize : the max size (in MB) of archived files to keep * minSize : the minimum freespace (in MB) on the filesytem to maintain when archiving * auto-flush : if true, log information is written immediately to disk; otherwise log file is buffered and written intermittently (slightly better performance)","title":"log file"},{"location":"drachtio-server/configuring/#loglevel","text":"The overall system log level: 'notice', 'warning', 'error', 'info, or 'debug'. loglevel info /loglevel Note: 'info' is the recommended log level for production systems. At this log level you will get sip traces, which are useful for debugging.","title":"loglevel"},{"location":"drachtio-server/configuring/#sofia-loglevel","text":"The drachtio server uses the sofia library internally. The log level for this library can be set from 0 (minimal) to 9 (extensive). sofia-loglevel 3 /sofia-loglevel","title":"sofia-loglevel"},{"location":"drachtio-server/configuring/#command-line-arguments","text":"The drachtio executable can accept command-line arguments that specify some configuration parameters. If provided, the command-line configuration parameters take preference over those specified in the configuration file. The supported drachtio command-line arguments are: * --daemon detach from the console and run as a daemon process. Note: when running as a systemd service, this parameter is not necessary. * --noconfig ignore any logging configuration in the configuration file * --file|-f filename read configuration from specified file rather that /etc/drachtio.conf.xml * --user|-u user run as the named user rather than root * --port|-p port listen for tcp admin connections on the named port * --tls-port listen for tls admin connections on the named port. Added in version 0.8.0-rc1 . * --contact|-c specifies a listening address/port/protocol. Multiple instances of this parameter may be provided * --external-ip ip-address specifies an external address that the drachtio server should advertise in the SIP signaling. This parameter applies to the --contact parameter that it follows in the command line. * dns-name name a dns name that refer to the local server. This parameter applies to the --contact parameter that it follows in the command line. * http-handler url an HTTP URL of a web callback that will be invoked for all new incoming requests. Setting this parameter turns on outbound connections for all SIP request types. * http-method either 'GET' or 'PUT' * --loglevel level the overall log level to set * --sofia-loglevel level the log level of the sofia library * --stdout write log output to console * --homer ip-address:port ip address of homer capture server to send to. HEP3 and udp transport will be used * --homer-id id id to use to represent this server when sending messages to homer * --version print the drachtio server version to console and exit. * --mtu specifies a message size, in bytes, for requests such that when outgoing requests exceed this threshold use of tcp is forced (this overrides the default sofia stack setting for the same). Added in version 0.7.3-rc2 . * --dh-param dhparam file used for inbound tls admin connections. Added in version 0.8.0-rc1 .","title":"command-line arguments"},{"location":"drachtio-server/installing/","text":"Installing Source for drachtio server can be obtained from github (build instructions can also be found there). The drachtio server has been tested on most Linux distributions, but the preferred deployment (because it has been the most heavily tested) is Debian 8 (Jesse). For those who use Ansible for automating builds, an ansible role is available. Finally, a docker image is also available via: docker pull drachtio/drachtio-server:latest Please post any issues here if you have problems building","title":"installing"},{"location":"drachtio-server/installing/#installing","text":"Source for drachtio server can be obtained from github (build instructions can also be found there). The drachtio server has been tested on most Linux distributions, but the preferred deployment (because it has been the most heavily tested) is Debian 8 (Jesse). For those who use Ansible for automating builds, an ansible role is available. Finally, a docker image is also available via: docker pull drachtio/drachtio-server:latest Please post any issues here if you have problems building","title":"Installing"},{"location":"drachtio-server/messaging-protocol/","text":"Messaging protocol Note: This article is a work in progress. The drachtio server is controlled by drachtio-srf applications using a utf8-based messaging protocol over a tcp connection. Because some developers have expressed an interest in integrating other language frameworks (e.g. go) to the drachtio server, this section aims to give some details of that protocol. As highlighted above, it is a work in progress. As per the documention found elsewhere on this site, drachtio supports both inbound and outbound connections. To begin with, we will focus here on describing the message flows for inbound connections. Basic message format Messages are utf8-encoded. (This was not always the case - originally ascii was used, but this broke down with applications that needed to receive and send information like emojis!). Each message starts with a decimal number indicating the number of bytes in the message (again, this is utf-8 so number of characters does not necessarily mean number of bytes!), followed by a hash sign ('#'). The number of bytes specified does not include these leading decimal digits or the hash sign -- they indicate the length of the payload that follows. The messsge payload that follows this consists of 1 or more lines of data, where each line is terminated by a CRLF. Typically, the first line of payload data consists of a list of tokens, where each token is delimited by a '|' character. When SIP messages are exchanged between application and server, these are usually carried starting on the second line of data, and are simply represented exactly as they appear \"on the wire\" between SIP endpoints. How to see messages being exchanged For those interested, note that is is possible to generate a trace file of all messaging between the client and the server by setting a property on the Srf instance, e.g.: const Srf = require('drachtio-srf'); const srf = new Srf(); // this will cause all messages between client and server to be logged to a file srf.set('api logger', '/tmp/messages.log'); Connection and authentication An inbound connection scenario starts when an application, acting as a TCP client, connects to a drachtio server on its configured admin port. After the connection is established, the application must authenticate itself via the shared secret that is configured in the drachtio.conf.xml configuration file on the server. If the client is authenticated, the server returns information including the sip hostports (e.g. list of address:port) that the server is listening on. Let's look at an example of a successful authentication. Not all of this will immediately be clear, but we will review the individual message elements below. === 56#12ad33a1-9f33-40b7-b327-b2e32bfcd9e8|authenticate|cymru| ===465#2f8216a3-babf-4cdb-93c6-254fe8dba42d|response|12ad33a1-9f33-40b7-b327-b2e32bfcd9e8|OK|tcp/[::1]:5060,udp/[::1]:5060,tcp/127.0.0.1:5060,tcp/10.0.0.121:5060,udp/127.0.0.1:5060,tcp/[2601:182:cd00:5786::4a1e]:5060,udp/[2601:182:cd00:5786::4a1e]:5060,tcp/[2601:182:cd00:5786:a534:e8d4:3dcb:3553]:5060,udp/[2601:182:cd00:5786:a534:e8d4:3dcb:3553]:5060,udp/10.0.0.121:5060,tcp/[2601:182:cd00:5786:1866:49f9:e83b:9574]:5060,udp/[2601:182:cd00:5786:1866:49f9:e83b:9574]:5060 Note: the direction === indicates a message sent from an application to the server; the reverse indicates a message sent from the server to the application We see that after connecting, the application sends an authenticate request to the server. The authenticate request consists of a single line containing three (3) tokens: * a unique message identifier, generated by the client application (needs to be unique only for this client), * the message type ('authenticate') * the shared secret ('cymru') The server validates the shared secret, and returns a message consisting of one line, containing the following tokens: * a unique message identifier for the response * the message type ('response') * the message id of the associated request * the response status ('OK') * a comma-delimited string containing the sip hostports the server is listening on At this point, the client has connected and authenticated successfully, but it has not yet registered the SIP request types that it would like to receive. That happens next. Registering to handle SIP requests In order to notify the server that the application wishes to handle specific SIP request types, it is necessary to issue a 'route' command. This is typically the next thing a client application does after authenticating. It is only necessary to register for request types once, during startup (i.e., after actually handling an incoming request it is not necessary to re-register in order to get further requests). Registering for request types is taken care of automatically in a drachtio-srf app when a srf.invite() statement is processed, for example. # registering to receive INVITEs === 49#5e60fef0-409f-4980-a859-94810d002ebb|route|invite ===85#e7470b05-95be-448e-94cd-3935292c4956|response|5e60fef0-409f-4980-a859-94810d002ebb|OK Note: to register for multiple request types (e.g. INVITE and REGISTER) the application must issue spearate 'route' commands. The 'route' command consists of a single line containing the following tokens: * a message id * the command ('route') * the SIP request type The response, as before, contains its own message id as well as the message id of the request, and the status ('OK'). At this point, the server will start sending SIP requests of the requested type to the application for handling. Let's look at what happens next. Handling an incoming SIP request Let's start with something simple: receiving a SIP INVITE and sending a non-success response. The basic message flow is this: * The server receives a SIP INVITE, selects the client application to send it to for handling, and sends a 'sip' message type to the client app containing the full SIP request message, as well as additional detail (e.g. the source_address and port etc) * The client application receives the message and sends a sip response message, containing at least the SIP status as well as any headers that it wants set to any non-default values. * The server sends out the SIP response on the network and then sends another message back to the client containing the exact message that was sent out over the wire. With that as background, let's examine the message trace. To make it interesting, we will have the client application add a custom SIP header to the response. We will also see now our first example of messages containining multiple lines, since we are now carrying SIP messages back and forth between client and server: ===866#83936ddb-523a-4cd0-886e-92b484905d85|sip|network|732|udp|127.0.0.1|50500|16:06:41.114233|8f62909b-0f25-4bb8-b0fc-2c0ec88a4afe|\\r\\n INVITE sip:15083084809@127.0.0.1 SIP/2.0\\r\\n Via: SIP/2.0/UDP 127.0.0.1:50500;branch=z9hG4bK-524287-1---f8002e51f06e3b38;rport=50500\\r\\n Max-Forwards: 70\\r\\n Contact: sip:dhorton@127.0.0.1:50500 \\r\\n To: sip:15083084809@127.0.0.1 \\r\\n From: sip:dhorton@127.0.0.1 ;tag=ce2ff21e\\r\\n Call-ID: 92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E\\r\\n CSeq: 1 INVITE\\r\\n Allow: SUBSCRIBE, NOTIFY, INVITE, ACK, CANCEL, BYE, REFER, INFO, OPTIONS\\r\\n Content-Type: application/sdp\\r\\n Supported: replaces\\r\\nUser-Agent: Bria 5 release 5.3.1 stamp 92383\\r\\n Content-Length: 202\\r\\n \\r\\n v=0\\r\\n o=- 1531670801092727 1 IN IP4 127.0.0.1\\r\\n s=Bria 5 release 5.3.1 stamp 92383\\r\\n c=IN IP4 127.0.0.1\\r\\n t=0 0\\r\\n m=audio 52282 RTP/AVP 0 101\\r\\n a=rtpmap:101 telephone-event/8000\\r\\n a=fmtp:101 0-15\\r\\n a=sendrecv\\r\\n === 332#829ba63e-5010-4719-b72f-cb3cf6f4aab2|sip|8f62909b-0f25-4bb8-b0fc-2c0ec88a4afe|\\r\\n SIP/2.0 486 Busy Here\\r\\n Call-ID: 92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E\\r\\n cseq: 1 INVITE\\r\\n from: sip:dhorton@127.0.0.1 ;tag=ce2ff21e\\r\\n to: sip:15083084809@127.0.0.1 \\r\\n Content-Length: 0\\r\\nuser-agent: drachtio\\r\\n X-custom: my custom header value\\r\\n ===600#d04f4d88-108c-4d93-a3f9-e9967b63ff55|response|829ba63e-5010-4719-b72f-cb3cf6f4aab2|OK|application|359|udp|127.0.0.1|50500|16:06:41.127954|8f62909b-0f25-4bb8-b0fc-2c0ec88a4afe|92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E;uas||Msg sent:|\\r\\n SIP/2.0 486 Busy Here\\r\\n Via: SIP/2.0/UDP 127.0.0.1:50500;branch=z9hG4bK-524287-1---f8002e51f06e3b38;rport=50500\\r\\n From: sip:dhorton@127.0.0.1 ;tag=ce2ff21e\\r\\n To: sip:15083084809@127.0.0.1 ;tag=cjSXXKtQejgrg\\r\\n Call-ID: 92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E\\r\\n CSeq: 1 INVITE\\r\\n User-Agent: drachtio\\r\\n Content-Length: 0\\r\\n X-custom: my custom header value\\r\\n Let's examine the first message -- the one sent by the server to the application, giving it an incoming INVITE message to handle. As usual, after the length specifier we see the message payload begins with the message identifier. After that, we have the message type, which in this case is 'sip'. We've now almost all of the message types (there aren't that many!), so let's pause here and briefly give the full list: * 'authenticate' * 'route' * 'response' * 'sip' * 'cdr:attempt' * 'cdr:start' * 'cdr:stop' In the case of a new incoming 'sip' request sent by the drachtio server we have the following tokens on the first line of the message payload: * message id * message type ('sip') * message source ('network' or 'application', depending on whether the app received or sent the msg) * length of the SIP message, as received over the wire * transport protocol * source address * source port * time message was received (as reported by the sofia sip stack) * unique id assigned by the server for this SIP transaction * unique id assigned by the server for this SIP Dialog (not always present, since a Dialog may not exist for this request) Following the first line of payload the incoming SIP message in its entirety is provided. At this point it is the responsibility of the application to return the desired SIP response that it wishes the server to send out. We see in the example above that the application also uses the 'sip' message type to accomplish this. The first line of payload contains the following tokens: * message id * message type ('sip') * the transaction id that the sip response pertains to Following that we have the message itself. Note that it is not necessary to provide the full SIP response message -- based on the transaction id, most of the headers will be supplied by the drachtio server. The application must minimally provide the SIP status line (in our example, drachtio-srf is populating several other headers such as To, From, etc but this should not be necessary). Additionally, if a body is desired in the response (which is not in our example), then that would be provided by the application as well (in the normal way of separating the body from any headers with two (2) CRLFs). The drachtio server sends out the indicated response and then notifies the application of the exact SIP response that was sent out over the wire. This allows the application to learn about information, such as the tag on the SIP To header, that the server itself would have applied. This final message has the following payload: * message id * message type ('response') * related message id (in this case, the 'sip' response message sent by the application) * message status ('OK') * message source ('application', indicating this was a message sent by the application) * length of the SIP message * transport protocol used * remote address sent to * remote port sent to * time message was sent (as reported by the sofia sip stack) * related transaction id * unique dialog id created by the server to represent this SIP Dialog Note: the additional tokens at the end of the first line (a blank token, and the string 'Msg sent') can be ignored; they are placeholders that are used in scenarios where the application has sent a SIP request, not a response.","title":"messaging protocol"},{"location":"drachtio-server/messaging-protocol/#messaging-protocol","text":"Note: This article is a work in progress. The drachtio server is controlled by drachtio-srf applications using a utf8-based messaging protocol over a tcp connection. Because some developers have expressed an interest in integrating other language frameworks (e.g. go) to the drachtio server, this section aims to give some details of that protocol. As highlighted above, it is a work in progress. As per the documention found elsewhere on this site, drachtio supports both inbound and outbound connections. To begin with, we will focus here on describing the message flows for inbound connections.","title":"Messaging protocol"},{"location":"drachtio-server/messaging-protocol/#basic-message-format","text":"Messages are utf8-encoded. (This was not always the case - originally ascii was used, but this broke down with applications that needed to receive and send information like emojis!). Each message starts with a decimal number indicating the number of bytes in the message (again, this is utf-8 so number of characters does not necessarily mean number of bytes!), followed by a hash sign ('#'). The number of bytes specified does not include these leading decimal digits or the hash sign -- they indicate the length of the payload that follows. The messsge payload that follows this consists of 1 or more lines of data, where each line is terminated by a CRLF. Typically, the first line of payload data consists of a list of tokens, where each token is delimited by a '|' character. When SIP messages are exchanged between application and server, these are usually carried starting on the second line of data, and are simply represented exactly as they appear \"on the wire\" between SIP endpoints.","title":"Basic message format"},{"location":"drachtio-server/messaging-protocol/#how-to-see-messages-being-exchanged","text":"For those interested, note that is is possible to generate a trace file of all messaging between the client and the server by setting a property on the Srf instance, e.g.: const Srf = require('drachtio-srf'); const srf = new Srf(); // this will cause all messages between client and server to be logged to a file srf.set('api logger', '/tmp/messages.log');","title":"How to see messages being exchanged"},{"location":"drachtio-server/messaging-protocol/#connection-and-authentication","text":"An inbound connection scenario starts when an application, acting as a TCP client, connects to a drachtio server on its configured admin port. After the connection is established, the application must authenticate itself via the shared secret that is configured in the drachtio.conf.xml configuration file on the server. If the client is authenticated, the server returns information including the sip hostports (e.g. list of address:port) that the server is listening on. Let's look at an example of a successful authentication. Not all of this will immediately be clear, but we will review the individual message elements below. === 56#12ad33a1-9f33-40b7-b327-b2e32bfcd9e8|authenticate|cymru| ===465#2f8216a3-babf-4cdb-93c6-254fe8dba42d|response|12ad33a1-9f33-40b7-b327-b2e32bfcd9e8|OK|tcp/[::1]:5060,udp/[::1]:5060,tcp/127.0.0.1:5060,tcp/10.0.0.121:5060,udp/127.0.0.1:5060,tcp/[2601:182:cd00:5786::4a1e]:5060,udp/[2601:182:cd00:5786::4a1e]:5060,tcp/[2601:182:cd00:5786:a534:e8d4:3dcb:3553]:5060,udp/[2601:182:cd00:5786:a534:e8d4:3dcb:3553]:5060,udp/10.0.0.121:5060,tcp/[2601:182:cd00:5786:1866:49f9:e83b:9574]:5060,udp/[2601:182:cd00:5786:1866:49f9:e83b:9574]:5060 Note: the direction === indicates a message sent from an application to the server; the reverse indicates a message sent from the server to the application We see that after connecting, the application sends an authenticate request to the server. The authenticate request consists of a single line containing three (3) tokens: * a unique message identifier, generated by the client application (needs to be unique only for this client), * the message type ('authenticate') * the shared secret ('cymru') The server validates the shared secret, and returns a message consisting of one line, containing the following tokens: * a unique message identifier for the response * the message type ('response') * the message id of the associated request * the response status ('OK') * a comma-delimited string containing the sip hostports the server is listening on At this point, the client has connected and authenticated successfully, but it has not yet registered the SIP request types that it would like to receive. That happens next.","title":"Connection and authentication"},{"location":"drachtio-server/messaging-protocol/#registering-to-handle-sip-requests","text":"In order to notify the server that the application wishes to handle specific SIP request types, it is necessary to issue a 'route' command. This is typically the next thing a client application does after authenticating. It is only necessary to register for request types once, during startup (i.e., after actually handling an incoming request it is not necessary to re-register in order to get further requests). Registering for request types is taken care of automatically in a drachtio-srf app when a srf.invite() statement is processed, for example. # registering to receive INVITEs === 49#5e60fef0-409f-4980-a859-94810d002ebb|route|invite ===85#e7470b05-95be-448e-94cd-3935292c4956|response|5e60fef0-409f-4980-a859-94810d002ebb|OK Note: to register for multiple request types (e.g. INVITE and REGISTER) the application must issue spearate 'route' commands. The 'route' command consists of a single line containing the following tokens: * a message id * the command ('route') * the SIP request type The response, as before, contains its own message id as well as the message id of the request, and the status ('OK'). At this point, the server will start sending SIP requests of the requested type to the application for handling. Let's look at what happens next.","title":"Registering to handle SIP requests"},{"location":"drachtio-server/messaging-protocol/#handling-an-incoming-sip-request","text":"Let's start with something simple: receiving a SIP INVITE and sending a non-success response. The basic message flow is this: * The server receives a SIP INVITE, selects the client application to send it to for handling, and sends a 'sip' message type to the client app containing the full SIP request message, as well as additional detail (e.g. the source_address and port etc) * The client application receives the message and sends a sip response message, containing at least the SIP status as well as any headers that it wants set to any non-default values. * The server sends out the SIP response on the network and then sends another message back to the client containing the exact message that was sent out over the wire. With that as background, let's examine the message trace. To make it interesting, we will have the client application add a custom SIP header to the response. We will also see now our first example of messages containining multiple lines, since we are now carrying SIP messages back and forth between client and server: ===866#83936ddb-523a-4cd0-886e-92b484905d85|sip|network|732|udp|127.0.0.1|50500|16:06:41.114233|8f62909b-0f25-4bb8-b0fc-2c0ec88a4afe|\\r\\n INVITE sip:15083084809@127.0.0.1 SIP/2.0\\r\\n Via: SIP/2.0/UDP 127.0.0.1:50500;branch=z9hG4bK-524287-1---f8002e51f06e3b38;rport=50500\\r\\n Max-Forwards: 70\\r\\n Contact: sip:dhorton@127.0.0.1:50500 \\r\\n To: sip:15083084809@127.0.0.1 \\r\\n From: sip:dhorton@127.0.0.1 ;tag=ce2ff21e\\r\\n Call-ID: 92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E\\r\\n CSeq: 1 INVITE\\r\\n Allow: SUBSCRIBE, NOTIFY, INVITE, ACK, CANCEL, BYE, REFER, INFO, OPTIONS\\r\\n Content-Type: application/sdp\\r\\n Supported: replaces\\r\\nUser-Agent: Bria 5 release 5.3.1 stamp 92383\\r\\n Content-Length: 202\\r\\n \\r\\n v=0\\r\\n o=- 1531670801092727 1 IN IP4 127.0.0.1\\r\\n s=Bria 5 release 5.3.1 stamp 92383\\r\\n c=IN IP4 127.0.0.1\\r\\n t=0 0\\r\\n m=audio 52282 RTP/AVP 0 101\\r\\n a=rtpmap:101 telephone-event/8000\\r\\n a=fmtp:101 0-15\\r\\n a=sendrecv\\r\\n === 332#829ba63e-5010-4719-b72f-cb3cf6f4aab2|sip|8f62909b-0f25-4bb8-b0fc-2c0ec88a4afe|\\r\\n SIP/2.0 486 Busy Here\\r\\n Call-ID: 92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E\\r\\n cseq: 1 INVITE\\r\\n from: sip:dhorton@127.0.0.1 ;tag=ce2ff21e\\r\\n to: sip:15083084809@127.0.0.1 \\r\\n Content-Length: 0\\r\\nuser-agent: drachtio\\r\\n X-custom: my custom header value\\r\\n ===600#d04f4d88-108c-4d93-a3f9-e9967b63ff55|response|829ba63e-5010-4719-b72f-cb3cf6f4aab2|OK|application|359|udp|127.0.0.1|50500|16:06:41.127954|8f62909b-0f25-4bb8-b0fc-2c0ec88a4afe|92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E;uas||Msg sent:|\\r\\n SIP/2.0 486 Busy Here\\r\\n Via: SIP/2.0/UDP 127.0.0.1:50500;branch=z9hG4bK-524287-1---f8002e51f06e3b38;rport=50500\\r\\n From: sip:dhorton@127.0.0.1 ;tag=ce2ff21e\\r\\n To: sip:15083084809@127.0.0.1 ;tag=cjSXXKtQejgrg\\r\\n Call-ID: 92383ZWEzZGI3MTY4NDRiMGI1ZTRhYjc2YWQ4ZTE1OWY4N2E\\r\\n CSeq: 1 INVITE\\r\\n User-Agent: drachtio\\r\\n Content-Length: 0\\r\\n X-custom: my custom header value\\r\\n Let's examine the first message -- the one sent by the server to the application, giving it an incoming INVITE message to handle. As usual, after the length specifier we see the message payload begins with the message identifier. After that, we have the message type, which in this case is 'sip'. We've now almost all of the message types (there aren't that many!), so let's pause here and briefly give the full list: * 'authenticate' * 'route' * 'response' * 'sip' * 'cdr:attempt' * 'cdr:start' * 'cdr:stop' In the case of a new incoming 'sip' request sent by the drachtio server we have the following tokens on the first line of the message payload: * message id * message type ('sip') * message source ('network' or 'application', depending on whether the app received or sent the msg) * length of the SIP message, as received over the wire * transport protocol * source address * source port * time message was received (as reported by the sofia sip stack) * unique id assigned by the server for this SIP transaction * unique id assigned by the server for this SIP Dialog (not always present, since a Dialog may not exist for this request) Following the first line of payload the incoming SIP message in its entirety is provided. At this point it is the responsibility of the application to return the desired SIP response that it wishes the server to send out. We see in the example above that the application also uses the 'sip' message type to accomplish this. The first line of payload contains the following tokens: * message id * message type ('sip') * the transaction id that the sip response pertains to Following that we have the message itself. Note that it is not necessary to provide the full SIP response message -- based on the transaction id, most of the headers will be supplied by the drachtio server. The application must minimally provide the SIP status line (in our example, drachtio-srf is populating several other headers such as To, From, etc but this should not be necessary). Additionally, if a body is desired in the response (which is not in our example), then that would be provided by the application as well (in the normal way of separating the body from any headers with two (2) CRLFs). The drachtio server sends out the indicated response and then notifies the application of the exact SIP response that was sent out over the wire. This allows the application to learn about information, such as the tag on the SIP To header, that the server itself would have applied. This final message has the following payload: * message id * message type ('response') * related message id (in this case, the 'sip' response message sent by the application) * message status ('OK') * message source ('application', indicating this was a message sent by the application) * length of the SIP message * transport protocol used * remote address sent to * remote port sent to * time message was sent (as reported by the sofia sip stack) * related transaction id * unique dialog id created by the server to represent this SIP Dialog Note: the additional tokens at the end of the first line (a blank token, and the string 'Msg sent') can be ignored; they are placeholders that are used in scenarios where the application has sent a SIP request, not a response.","title":"Handling an incoming SIP request"},{"location":"drachtio-server/running/","text":"Running The drachtio-server executable built from source code is simply named drachtio . By default, the build process installs it in /usr/local/bin/drachtio . On systemd distributions, drachtio can be installed as a systemd service -- the ansible role does this automatically; on a build from source the systemd script can be found here . The following options are supported: $ systemctl [start|stop|restart|status] drachtio Command-line options for the drachtio executable will be covered in the following section.","title":"running"},{"location":"drachtio-server/running/#running","text":"The drachtio-server executable built from source code is simply named drachtio . By default, the build process installs it in /usr/local/bin/drachtio . On systemd distributions, drachtio can be installed as a systemd service -- the ansible role does this automatically; on a build from source the systemd script can be found here . The following options are supported: $ systemctl [start|stop|restart|status] drachtio Command-line options for the drachtio executable will be covered in the following section.","title":"Running"},{"location":"release-notes/drachtio-server/release-notes/","text":"0.8.4 fix travis osx build add support for specifying number of log files to keep bugfix: crash sending ACK to target with dns name that needs to be resolved (110) bugfix - crash when RR header in 200 OK response has dns name (#110) add tests for handling reinvite with null sdp and invoking fnAck add dialogid to msgs back to app when sending a response within a dialog pass ip address:port new incoming request was received on to client applications bugfix: address to bind to for client connections was being ignored (#103) add support for adding headers to CANCEL request add support for tcp keepalive return 491 Request Pending if we receive a re-INVITE while still processing a previous INVITE transaction travis change to build node 10.x for tests temp revert nta_outgoing_destroy due to crash (#76) 0.8.3 0.8.2 simplify timerD handling, fix some memory leaks related to not destroying sofia transactions in UAC scenarios change dialog id naming convention to \"{call-id};from-tag={from-tag}\", which more correctly maps to SIP standard and simplifies transfer scenarios in applications add support for detecting public ip when running in a Docker container in Azure cloud include server version in response to authenticate command (allows clients to activate version-specific features). Version info is available to client (when using drachtio-srf@4.4.8 or above, and connecting to a server at version 0.8.2 or above) as a parameter in the Srf#connect event, e.g.: srf.on('connect', (err, hp, serverVersion) = { console.log(serverVersion); // v.0.8.2 }); bugfix: generate proper CDRs for B2B scenarios add support for 'ping' request from client 0.8.1 added support for prometheuos.io monitoring added support for configuring some settings via environment variables update to boost 1.69 handle an incoming NOTIFY or request before dialog is formed (issue #75 ) changes to build properly on arm64 update to latest sofia 0.8.0 bugfix: crash when requested protocol is not enabled (issue #64) add support for nat detection based on appearance of nat=yes in the Record-Route or Contact header (issue #66). Some proxies are known to insert this when the detect nat scenarios. fix for some compile warnings. when choosing a transport for outbound invite, check the the protocol of the outbound proxy (if one is configured) include a transport= param in the Contact header in 200 OK response to incoming invite when transport is not udp (required by pjsip) add support for cloud deployments in Kubernetes where the public IP address must be dynamically discovered. added autogen.sh deprecating bootstrap.sh Major changes here to remove a lot of boost code which is now included in the C++ standard. Most notably, gcc 4.9 or above is now required. Compile with stdc++-17 if available, stdc++-11 if not. handle a mid-call network handoff, e.g. a client on a wifi network switches to LTE during a call - BYE should be sent to the new (on the LTE network) address. send ACK to failed response using same transport as response was received on. fix for sending to non-standard syslog UDP port, if specified in config. Added optional support for TLS encryption of messages between the drachtio server and drachtio-srf applications. Requires drachtio-srf@4.4.0 or above. set timerG and timerH only for udp transports. handle SIGPIPE without exiting - can happen occasionally when a client disconnects. eliminate confusing / contradictory GPL license text. 0.7.4 Added support for establishing uas INVITE dialogs with clients that are behind a nat. fix crashing bug in non-UDP transport scenarios that was introduced in 0.7.4-rc1 0.7.3 Added support for tagged inbound connections; requires drachtio-srf@4.3.0 or above. client-server messaging changed from ascii to utf-8 in order to support message bodies with things like emojis. various Dockerfile fixes. run-time tests added and travis-ci changes to accomodate them. sofia-sip has an annoying feature where it forces an outbound request to go out TCP if the packet size exceeds a specific threshold (usually 1300 bytes). A new configuration setting was added to allow users to increase this threshold to an arbitrary value. This value can be provided in the configuration file, or via a command-line parameter, as illustrated below. in drachtio.conf.xml 4096 or, on command-line drachtio --mtu 4096 Some clients (e.g. Tandberg) have an annoying habit of included a Route header on an initial INVITE; i.e. a \"preloaded\" Route header. When proxying such an INVITE, the server now strips that header before sending the request onwards, so as not to confuse downstream elements. Ensure that 'from' tag on new outbound SIP requests use the local tag on the nta leg. There were cases when an INVITE was challenged that the subsequent INVITE w/ authorization credentials was using the old tag from the completed leg, rather than the new leg created for the second request.","title":"drachtio-server"},{"location":"release-notes/drachtio-server/release-notes/#084","text":"fix travis osx build add support for specifying number of log files to keep bugfix: crash sending ACK to target with dns name that needs to be resolved (110) bugfix - crash when RR header in 200 OK response has dns name (#110) add tests for handling reinvite with null sdp and invoking fnAck add dialogid to msgs back to app when sending a response within a dialog pass ip address:port new incoming request was received on to client applications bugfix: address to bind to for client connections was being ignored (#103) add support for adding headers to CANCEL request add support for tcp keepalive return 491 Request Pending if we receive a re-INVITE while still processing a previous INVITE transaction travis change to build node 10.x for tests temp revert nta_outgoing_destroy due to crash (#76)","title":"0.8.4"},{"location":"release-notes/drachtio-server/release-notes/#083","text":"","title":"0.8.3"},{"location":"release-notes/drachtio-server/release-notes/#082","text":"simplify timerD handling, fix some memory leaks related to not destroying sofia transactions in UAC scenarios change dialog id naming convention to \"{call-id};from-tag={from-tag}\", which more correctly maps to SIP standard and simplifies transfer scenarios in applications add support for detecting public ip when running in a Docker container in Azure cloud include server version in response to authenticate command (allows clients to activate version-specific features). Version info is available to client (when using drachtio-srf@4.4.8 or above, and connecting to a server at version 0.8.2 or above) as a parameter in the Srf#connect event, e.g.: srf.on('connect', (err, hp, serverVersion) = { console.log(serverVersion); // v.0.8.2 }); bugfix: generate proper CDRs for B2B scenarios add support for 'ping' request from client","title":"0.8.2"},{"location":"release-notes/drachtio-server/release-notes/#081","text":"added support for prometheuos.io monitoring added support for configuring some settings via environment variables update to boost 1.69 handle an incoming NOTIFY or request before dialog is formed (issue #75 ) changes to build properly on arm64 update to latest sofia","title":"0.8.1"},{"location":"release-notes/drachtio-server/release-notes/#080","text":"bugfix: crash when requested protocol is not enabled (issue #64) add support for nat detection based on appearance of nat=yes in the Record-Route or Contact header (issue #66). Some proxies are known to insert this when the detect nat scenarios. fix for some compile warnings. when choosing a transport for outbound invite, check the the protocol of the outbound proxy (if one is configured) include a transport= param in the Contact header in 200 OK response to incoming invite when transport is not udp (required by pjsip) add support for cloud deployments in Kubernetes where the public IP address must be dynamically discovered. added autogen.sh deprecating bootstrap.sh Major changes here to remove a lot of boost code which is now included in the C++ standard. Most notably, gcc 4.9 or above is now required. Compile with stdc++-17 if available, stdc++-11 if not. handle a mid-call network handoff, e.g. a client on a wifi network switches to LTE during a call - BYE should be sent to the new (on the LTE network) address. send ACK to failed response using same transport as response was received on. fix for sending to non-standard syslog UDP port, if specified in config. Added optional support for TLS encryption of messages between the drachtio server and drachtio-srf applications. Requires drachtio-srf@4.4.0 or above. set timerG and timerH only for udp transports. handle SIGPIPE without exiting - can happen occasionally when a client disconnects. eliminate confusing / contradictory GPL license text.","title":"0.8.0"},{"location":"release-notes/drachtio-server/release-notes/#074","text":"Added support for establishing uas INVITE dialogs with clients that are behind a nat. fix crashing bug in non-UDP transport scenarios that was introduced in 0.7.4-rc1","title":"0.7.4"},{"location":"release-notes/drachtio-server/release-notes/#073","text":"Added support for tagged inbound connections; requires drachtio-srf@4.3.0 or above. client-server messaging changed from ascii to utf-8 in order to support message bodies with things like emojis. various Dockerfile fixes. run-time tests added and travis-ci changes to accomodate them. sofia-sip has an annoying feature where it forces an outbound request to go out TCP if the packet size exceeds a specific threshold (usually 1300 bytes). A new configuration setting was added to allow users to increase this threshold to an arbitrary value. This value can be provided in the configuration file, or via a command-line parameter, as illustrated below. in drachtio.conf.xml 4096 or, on command-line drachtio --mtu 4096 Some clients (e.g. Tandberg) have an annoying habit of included a Route header on an initial INVITE; i.e. a \"preloaded\" Route header. When proxying such an INVITE, the server now strips that header before sending the request onwards, so as not to confuse downstream elements. Ensure that 'from' tag on new outbound SIP requests use the local tag on the nta leg. There were cases when an INVITE was challenged that the subsequent INVITE w/ authorization credentials was using the old tag from the completed leg, rather than the new leg created for the second request.","title":"0.7.3"},{"location":"release-notes/drachtio-srf/release-notes/","text":"4.4.27 bugfix: copyAllHeaders needs to handle case where INVITE could not be sent 4.4.26 proxyRequestHeaders and proxyResponseHeaders now can take keyword 'all' to copy SIP headers from A to B leg without specifying them individually. Can also then selectively remove some; e.g. proxyRequestHeaders: ['all', '-Authorization'] . Note that headers such as To, From, Via, Contact, Route, Record-Route are never copied. 4.4.25 4.4.24 when calling fnAck provided in Response#send callback, pass the ACK/PRACK message as a parameter (partial fix for #70 ) 4.4.23 UAC: when sending request with credentials after challenge, make sure two From headers are not included (drachtio server issue 106) allow auth on in-dialog requests #67 4.4.22 Merge pull request #63 from Telzio/bugfix-isNewDialog for new incoming requests outside of a dialog, req.receiveOn contains the local sip endpoint that received the incoming request 65 4.4.21 4.4.20 race condition fix: b2bua, must wait for ACK from A before releasing queue of pending requests from B #62 4.4.19 Fixed bug where request.js calls non-existent method Merge pull request #61 from Telzio/feature-hold-unhold-events Only apply refresh/hold/unhold logic if these events are subscribed 4.4.18 #55 allow customization of From header; also remove unused api logging feature 4.4.15 bugfix: when b2b fails to send to B due to stack error or warning, no response was propgated to A 4.4.14 #15 - added attributes to req attribute that describe the drachtio server the request is coming from: req.server.address : the IP address the drachtio server sending the request. Note: this is the IP address the server is bound to for the tcp/tls socket connection to the application, which may be different than the IP address(es) that the server is listening on for SIP traffic. req.server.hostport : a list of SIP addresses and associated protocols that the drachtio server is listening on. This is the same information that is returned in the callback to the Srf#connect event 4.4.13 #48 fix memory leak in outbound scenario 4.4.12 #47 when using outbound connections CANCEL was sometimes sent to wrong server in B2B scenario 4.4.11 Dialog#modify now resolves to remote SDP received from reinvite 4.4.10 allow app to set explicitly tag on To header when responding bugfix: Honour original uri transport in challenge response fixes - issue 45 4.4.9 bugfix: race condition with immediate request within newly-formed dialog - issue 43 4.4.8 Added support for sending periodic 'ping' requests to the server. These are mainly useful to keep connections alive and active if they traverse network firewalls that may terminate tcp connections periodically if traffic has not been exchanged between the endpoints. This feature is disabled by default, but can be turned on by setting opts.enablePing when calling Srf#connect or Srf#listen, e.g. srf.connect({ host: '127.0.0.1', port: 9022, secret: 'cymru', enablePing: true }); The default ping interval is 15 seconds. You can change this by setting opts.pingInterval to a value of milliseconds (must be = 5000 and = 300000); for instance, to set the ping interval to 45 seconds: srf.connect({ host: '127.0.0.1', port: 9022, secret: 'cymru', enablePing: true, pingInterval: 45000 }); The server responds with a 'pong' message (note that you do not need to do anything to handle this; it is not exposed to the application level). This feature requires a drachtio server version of v0.8.2 or above; however, it is safe to call it against earlier versions (there just won't be any ping messages sent). 4.4.7 add Srf#findDialogById and Srf#findDialogByCallIDAndFromTag, the latter is particularly useful in handling attended transfer scenarios per issue #34 migrated by istanbul to nyc for code coverage 4.4.6 make metadata available with destroy and ack events bugfix: parse sip scheme properly ( pull request #33 ) 4.4.5 pass request request metadata in dialog events; e.g. so when handling a BYE metadata such as the stack time of the message is available. 4.4.4 bugfix: opts.localSdpA in Srf#createB2BUA should allow for a function returning a string, as documented. (Other options are for opts.localSdpA simply to be a string, or a function returning a Promise that resolves to a string). 4.4.3 update to latest drachtio-sip with bugfix for parsing multipart content-type header (fixes bug identified when handling SIPREC invite from Oracle/Acme) update to latest drachtio-sip to remove security warning 4.4.2 add algorithm=MD when constructing Authorization header (this is optional per spec, but some require it) 4.4.1 When handling a Digest challenge as a UAC after sending the initial request to a DNS name, send the follow-up credentialled request to the responding server ip address, rather than doing another DNS lookup. Export Request and SipMessage classes (mainly needed to construct test scenarios). 4.4.0 Added optional support for TLS encryption of messages between the drachtio server and drachtio-srf applications. Requires drachtio-server@0.8.0-rc1 or above. 4.3.7 Fixed bug parsing messages from drachtio server that was causing intermittent \"invalid message from server, did not start with..\" errors when receiving a CANCEL that we cant relate to a pending INVITE, silently discard instead of returning 404 4.3.6 Fixed race condition when app CANCELs a uac INVITE in the midst of handling a 401/407 challenge response. 4.3.5 Fixed bug in Dialog#handle where an incoming NOTIFY request with a Subscription-State header was assumed to be for a SUBCRIBE dialog - this is not the case for a NOTIFY after a REFER. Fix bug in Digest authentication: nc and algorithm values should not be in quotes in Authorization (or Proxy-Authorization) header. 4.3.4 Added opts.responseHeaders to Srf#createB2BUA to provide SIP headers to include on responses to the A party. The value may be either an object containing the SIP headers to apply on all responses to the A party (provisional as well as final), or a function returning an object that contains the SIP headers to apply. If a function is provided, it will be called with the signature (uacRes, headers) , where uacRes is the response received from the B party, and headers are the SIP headers that have already been set on the response message to the A party (e.g., through the opts.proxyResponse option). 4.3.3 Fixed uac scenario ( srf.createUAC or srf.createB2BUA ) where opts.auth is provided and 401/407 challenge is handled. The stack transaction for the initial request was being incorrectly used to send the CANCEL or ACK for the subsequent request (the one carrying credentials). 4.3.2 Fixed regression bug in recent change to Srf#request . 4.3.1 Fix bug in Dialog#request where Promise was not being resolved properly with the received response to the outbound request. Srf#proxyRequest and Srf#request now return Promises when no callback provided, for consistency with other methods 4.3.0 Added support for tagged inbound connections. Bundled functionality that was originally in the drachtio module; package.json now only requires drachtio-srf (i.e. do not include drachtio as a dependency).","title":"drachtio-srf"},{"location":"release-notes/drachtio-srf/release-notes/#4427","text":"bugfix: copyAllHeaders needs to handle case where INVITE could not be sent","title":"4.4.27"},{"location":"release-notes/drachtio-srf/release-notes/#4426","text":"proxyRequestHeaders and proxyResponseHeaders now can take keyword 'all' to copy SIP headers from A to B leg without specifying them individually. Can also then selectively remove some; e.g. proxyRequestHeaders: ['all', '-Authorization'] . Note that headers such as To, From, Via, Contact, Route, Record-Route are never copied.","title":"4.4.26"},{"location":"release-notes/drachtio-srf/release-notes/#4425","text":"","title":"4.4.25"},{"location":"release-notes/drachtio-srf/release-notes/#4424","text":"when calling fnAck provided in Response#send callback, pass the ACK/PRACK message as a parameter (partial fix for #70 )","title":"4.4.24"},{"location":"release-notes/drachtio-srf/release-notes/#4423","text":"UAC: when sending request with credentials after challenge, make sure two From headers are not included (drachtio server issue 106) allow auth on in-dialog requests #67","title":"4.4.23"},{"location":"release-notes/drachtio-srf/release-notes/#4422","text":"Merge pull request #63 from Telzio/bugfix-isNewDialog for new incoming requests outside of a dialog, req.receiveOn contains the local sip endpoint that received the incoming request 65","title":"4.4.22"},{"location":"release-notes/drachtio-srf/release-notes/#4421","text":"","title":"4.4.21"},{"location":"release-notes/drachtio-srf/release-notes/#4420","text":"race condition fix: b2bua, must wait for ACK from A before releasing queue of pending requests from B #62","title":"4.4.20"},{"location":"release-notes/drachtio-srf/release-notes/#4419","text":"Fixed bug where request.js calls non-existent method Merge pull request #61 from Telzio/feature-hold-unhold-events Only apply refresh/hold/unhold logic if these events are subscribed","title":"4.4.19"},{"location":"release-notes/drachtio-srf/release-notes/#4418","text":"#55 allow customization of From header; also remove unused api logging feature","title":"4.4.18"},{"location":"release-notes/drachtio-srf/release-notes/#4415","text":"bugfix: when b2b fails to send to B due to stack error or warning, no response was propgated to A","title":"4.4.15"},{"location":"release-notes/drachtio-srf/release-notes/#4414","text":"#15 - added attributes to req attribute that describe the drachtio server the request is coming from: req.server.address : the IP address the drachtio server sending the request. Note: this is the IP address the server is bound to for the tcp/tls socket connection to the application, which may be different than the IP address(es) that the server is listening on for SIP traffic. req.server.hostport : a list of SIP addresses and associated protocols that the drachtio server is listening on. This is the same information that is returned in the callback to the Srf#connect event","title":"4.4.14"},{"location":"release-notes/drachtio-srf/release-notes/#4413","text":"#48 fix memory leak in outbound scenario","title":"4.4.13"},{"location":"release-notes/drachtio-srf/release-notes/#4412","text":"#47 when using outbound connections CANCEL was sometimes sent to wrong server in B2B scenario","title":"4.4.12"},{"location":"release-notes/drachtio-srf/release-notes/#4411","text":"Dialog#modify now resolves to remote SDP received from reinvite","title":"4.4.11"},{"location":"release-notes/drachtio-srf/release-notes/#4410","text":"allow app to set explicitly tag on To header when responding bugfix: Honour original uri transport in challenge response fixes - issue 45","title":"4.4.10"},{"location":"release-notes/drachtio-srf/release-notes/#449","text":"bugfix: race condition with immediate request within newly-formed dialog - issue 43","title":"4.4.9"},{"location":"release-notes/drachtio-srf/release-notes/#448","text":"Added support for sending periodic 'ping' requests to the server. These are mainly useful to keep connections alive and active if they traverse network firewalls that may terminate tcp connections periodically if traffic has not been exchanged between the endpoints. This feature is disabled by default, but can be turned on by setting opts.enablePing when calling Srf#connect or Srf#listen, e.g. srf.connect({ host: '127.0.0.1', port: 9022, secret: 'cymru', enablePing: true }); The default ping interval is 15 seconds. You can change this by setting opts.pingInterval to a value of milliseconds (must be = 5000 and = 300000); for instance, to set the ping interval to 45 seconds: srf.connect({ host: '127.0.0.1', port: 9022, secret: 'cymru', enablePing: true, pingInterval: 45000 }); The server responds with a 'pong' message (note that you do not need to do anything to handle this; it is not exposed to the application level). This feature requires a drachtio server version of v0.8.2 or above; however, it is safe to call it against earlier versions (there just won't be any ping messages sent).","title":"4.4.8"},{"location":"release-notes/drachtio-srf/release-notes/#447","text":"add Srf#findDialogById and Srf#findDialogByCallIDAndFromTag, the latter is particularly useful in handling attended transfer scenarios per issue #34 migrated by istanbul to nyc for code coverage","title":"4.4.7"},{"location":"release-notes/drachtio-srf/release-notes/#446","text":"make metadata available with destroy and ack events bugfix: parse sip scheme properly ( pull request #33 )","title":"4.4.6"},{"location":"release-notes/drachtio-srf/release-notes/#445","text":"pass request request metadata in dialog events; e.g. so when handling a BYE metadata such as the stack time of the message is available.","title":"4.4.5"},{"location":"release-notes/drachtio-srf/release-notes/#444","text":"bugfix: opts.localSdpA in Srf#createB2BUA should allow for a function returning a string, as documented. (Other options are for opts.localSdpA simply to be a string, or a function returning a Promise that resolves to a string).","title":"4.4.4"},{"location":"release-notes/drachtio-srf/release-notes/#443","text":"update to latest drachtio-sip with bugfix for parsing multipart content-type header (fixes bug identified when handling SIPREC invite from Oracle/Acme) update to latest drachtio-sip to remove security warning","title":"4.4.3"},{"location":"release-notes/drachtio-srf/release-notes/#442","text":"add algorithm=MD when constructing Authorization header (this is optional per spec, but some require it)","title":"4.4.2"},{"location":"release-notes/drachtio-srf/release-notes/#441","text":"When handling a Digest challenge as a UAC after sending the initial request to a DNS name, send the follow-up credentialled request to the responding server ip address, rather than doing another DNS lookup. Export Request and SipMessage classes (mainly needed to construct test scenarios).","title":"4.4.1"},{"location":"release-notes/drachtio-srf/release-notes/#440","text":"Added optional support for TLS encryption of messages between the drachtio server and drachtio-srf applications. Requires drachtio-server@0.8.0-rc1 or above.","title":"4.4.0"},{"location":"release-notes/drachtio-srf/release-notes/#437","text":"Fixed bug parsing messages from drachtio server that was causing intermittent \"invalid message from server, did not start with..\" errors when receiving a CANCEL that we cant relate to a pending INVITE, silently discard instead of returning 404","title":"4.3.7"},{"location":"release-notes/drachtio-srf/release-notes/#436","text":"Fixed race condition when app CANCELs a uac INVITE in the midst of handling a 401/407 challenge response.","title":"4.3.6"},{"location":"release-notes/drachtio-srf/release-notes/#435","text":"Fixed bug in Dialog#handle where an incoming NOTIFY request with a Subscription-State header was assumed to be for a SUBCRIBE dialog - this is not the case for a NOTIFY after a REFER. Fix bug in Digest authentication: nc and algorithm values should not be in quotes in Authorization (or Proxy-Authorization) header.","title":"4.3.5"},{"location":"release-notes/drachtio-srf/release-notes/#434","text":"Added opts.responseHeaders to Srf#createB2BUA to provide SIP headers to include on responses to the A party. The value may be either an object containing the SIP headers to apply on all responses to the A party (provisional as well as final), or a function returning an object that contains the SIP headers to apply. If a function is provided, it will be called with the signature (uacRes, headers) , where uacRes is the response received from the B party, and headers are the SIP headers that have already been set on the response message to the A party (e.g., through the opts.proxyResponse option).","title":"4.3.4"},{"location":"release-notes/drachtio-srf/release-notes/#433","text":"Fixed uac scenario ( srf.createUAC or srf.createB2BUA ) where opts.auth is provided and 401/407 challenge is handled. The stack transaction for the initial request was being incorrectly used to send the CANCEL or ACK for the subsequent request (the one carrying credentials).","title":"4.3.3"},{"location":"release-notes/drachtio-srf/release-notes/#432","text":"Fixed regression bug in recent change to Srf#request .","title":"4.3.2"},{"location":"release-notes/drachtio-srf/release-notes/#431","text":"Fix bug in Dialog#request where Promise was not being resolved properly with the received response to the outbound request. Srf#proxyRequest and Srf#request now return Promises when no callback provided, for consistency with other methods","title":"4.3.1"},{"location":"release-notes/drachtio-srf/release-notes/#430","text":"Added support for tagged inbound connections. Bundled functionality that was originally in the drachtio module; package.json now only requires drachtio-srf (i.e. do not include drachtio as a dependency).","title":"4.3.0"}]}